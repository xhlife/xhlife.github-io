{"meta":{"title":"cxhai-blog","subtitle":"","description":"","author":"cxh","url":"https://cxhai.top","root":"/"},"pages":[{"title":"","date":"2019-12-07T13:22:24.066Z","updated":"2019-12-06T09:03:56.421Z","comments":true,"path":"about/index.html","permalink":"https://cxhai.top/about/index.html","excerpt":"","text":"其实我是来讨打赏的！"}],"posts":[{"title":"策略模式","slug":"策略模式","date":"2020-01-28T03:08:59.000Z","updated":"2020-01-28T14:24:22.230Z","comments":true,"path":"2020/01/28/策略模式/","link":"","permalink":"https://cxhai.top/2020/01/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"说明在程序开发中，要实现某个功能有很多方案，要随意变换，那么就要用到策略模式。","text":"说明在程序开发中，要实现某个功能有很多方案，要随意变换，那么就要用到策略模式。 策略模式定义：定义一系列的算法，把他们封装起来，并且使它们可以相互替换。 使用策略模式计算奖金1var strategies = &#123;2 \"S\":function(salary)&#123;3 return salary * 44 &#125;,5 \"A\":function(salary)&#123;6 return salary * 37 &#125;,8 \"B\":function(salary)&#123;9 return salary * 210 &#125;11&#125;12var calculateBonus = function(level,salary)&#123;13 return strategies[level](salary)14&#125;15console.log(calculateBonus('S',20000)) // 80000 通过策略模式可以消除大量的条件分支语句（if/else）,在calculeteBonus()函数中只要获取策略对象的具体方法即可。 策略模式实现动画动画原理：在javascript中，可以通过连续改变元素的某个css属性，例如top,left等来实现动画。一些常见的缓动算法，接受四个参数。时间，起点，目标，持续时间。 1var tween = &#123;2 linear: function(time, begin, target, duration)&#123;3 return target * time / duration + begin4 &#125;,5 easeIn: function(time, begin, target, duration)&#123;6 return target * (time /= duration) * time + begin7 &#125;,8 strongEaseIn: function(time, begin, target, duration)&#123;9 return target * ( time /= duration ) * time * time * time * time + begin 10 &#125;,11 strongEaseout: function(time, begin, target, duration)&#123;12 return target * (( time = time / duration - 1) * time * time * time * time + 1) + begin; 13 &#125;,14 sineaseIn: function(time, begin, target, duration)&#123;15 return target * ( time /= duration) * time * time + begin; 16 &#125;,17 sineaseOUt: function(time, begin, target, duration)&#123;18 return target * ( ( time = time / duration - 1) * time * time + 1 ) + begin;19 &#125;20&#125; 定义Animate类，负责初始化dom节点。 1var Animate = function(dom)&#123;2 this.dom = dom3 this.startTime = 0 // 开始时间4 this.startPos = 0 // 起点位置5 this.endPos = 0 // 终点位置6 this.propertyName = null // 节点属性名7 this.easing = null // 缓动算法8 this.duration = null // 动画持续时间9&#125;10// 启动动画的方法11Animate.prototype.start = function(propertyName, endPos, duration, easing)&#123;12 this.startTime = +new Date13 // +new Date是new Date().getTime()的简写14 this.startPos = this.dom.getBoundingClientRect()[ propertyName ]; // dom 节点初始位置15 //Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。16 this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名17 this.endPos = endPos; // dom 节点目标位置18 this.duration = duration; // 动画持续事件19 this.easing = tween[ easing ]; // 缓动算法2021 var self = this;22 var timer = setInterval(function()&#123; // 启动定时器，开始执行动画23 if ( self.step() === false )&#123; // 如果动画已结束，则清除定时器24 clearInterval( timer ); 25 &#125;26 &#125;, 19 );27&#125;;28// 控制每一帧 29Animate.prototype.step = function()&#123;30 var t = +new Date; // 取得当前时间31 if ( t &gt;= this.startTime + this.duration )&#123; // (1)32 this.update( this.endPos ); // 更新小球的 CSS 属性值33 return false; // 条件满足则退出函数34 &#125;35 var pos = this.easing( t - this.startTime, this.startPos,36 this.endPos - this.startPos, this.duration );37 // pos 为小球当前位置38 this.update( pos ); // 更新小球的 CSS 属性值39&#125;; 40//更新属性41Animate.prototype.update = function( pos )&#123;42 this.dom.style[ this.propertyName ] = pos + 'px';43&#125;;44// 测试45// html代码 &lt;div id='div' style=\"...\"&gt;我是div&lt;div&gt;46var div = document.getElementById('div')47var animate = new Animate(div)48animate.start('left',500,800,'strongEaseOut') 策略模式-表单验证1&lt;html&gt;2 &lt;body&gt;3 &lt;form action=\"http:// xxx.com/register\" id=\"registerForm\" method=\"post\"&gt;4 请输入用户名：&lt;input type=\"text\" name=\"userName\"/ &gt;5 请输入密码：&lt;input type=\"text\" name=\"password\"/ &gt;6 请输入手机号码：&lt;input type=\"text\" name=\"phoneNumber\"/ &gt;7 &lt;button&gt;提交&lt;/button&gt;8 &lt;/form&gt;9 &lt;script&gt;10 var registerForm = document.getElementById( 'registerForm' );11 registerForm.onsubmit = function()&#123;12 if ( registerForm.userName.value === '' )&#123;13 alert ( '用户名不能为空' );14 return false;15 &#125;16 if ( registerForm.password.value.length &lt; 6 )&#123;17 alert ( '密码长度不能少于 6 位' );18 return false;19 &#125;20 if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( registerForm.phoneNumber.value ) )&#123;21 alert ( '手机号码格式不正确' );22 return false;23 &#125;24 &#125;25 &lt;/script&gt;26 &lt;/body&gt;27&lt;/html&gt; 上面的脚本中包含了大量的条件语句，包含了所有的校验规则。下面采用策略模式来重构表单验证代码。先将所有的校验逻辑封装起来 1var strategies = &#123;2 isNonEmpty: function( value, errorMsg )&#123; // 不为空3 if ( value === '' )&#123;4 return errorMsg ;5 &#125;6 &#125;,7 minLength: function( value, length, errorMsg )&#123; // 限制最小长度8 if ( value.length &lt; length )&#123;9 return errorMsg;10 &#125;11 &#125;,12 isMobile: function( value, errorMsg )&#123; // 手机号码格式13 if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( value ) )&#123;14 return errorMsg;15 &#125;16 &#125;17&#125;; 应该有个类，可以向input节点添加需要的验证规则。 1var Validator = function()&#123;2 this.cache = []; // 保存校验规则3&#125;;4// 添加校验规则的函数5Validator.prototype.add = function( dom, rule, errorMsg )&#123;6 var ary = rule.split( ':' ); // 把 strategy 和参数分开7 this.cache.push(function()&#123; // 把校验的步骤用空函数包装起来，并且放入 cache8 var strategy = ary.shift(); // 用户挑选的 strategy9 ary.unshift( dom.value ); // 把 input 的 value 添加进参数列表10 ary.push( errorMsg ); // 把 errorMsg 添加进参数列表11 return strategies[ strategy ].apply( dom, ary );12 &#125;);13&#125;;14// 开启验证的函数，并且返回验证结果15Validator.prototype.start = function()&#123;16 for ( var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ]; )&#123;17 var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息18 if ( msg )&#123; // 如果有确切的返回值，说明校验没有通过19 return msg;20 &#125;21 &#125;22&#125;; 2324// 向表单添加认证25var validataFunc = function()&#123;26 var validator = new Validator(); // 创建一个 validator 对象27 /***************添加一些校验规则****************/28 validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空' );29 validator.add( registerForm.password, 'minLength:6', '密码长度不能少于6位' );30 validator.add( registerForm.phoneNumber, 'isMobile', '手机号码格式不正确' );31 var errorMsg = validator.start(); // 获得校验结果32 return errorMsg; // 返回校验结果33&#125;34// 获取节点并实现onsubmit事件 35var registerForm = document.getElementById( 'registerForm' );36registerForm.onsubmit = function()&#123;37 var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验38 if ( errorMsg )&#123;39 alert ( errorMsg );40 return false; // 阻止表单提交41 &#125;42&#125;;","categories":[],"tags":[{"name":"javascript 设计模式","slug":"javascript-设计模式","permalink":"https://cxhai.top/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"javascript单例模式","slug":"javascript单例模式","date":"2020-01-26T08:37:31.000Z","updated":"2020-01-28T03:09:36.490Z","comments":true,"path":"2020/01/26/javascript单例模式/","link":"","permalink":"https://cxhai.top/2020/01/26/javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"说明单例模式是一种常用的模式。","text":"说明单例模式是一种常用的模式。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。在javascript中，我们经常使用全局的对象作为单例。例如：var a = {}这个对象a的确是独一无二的。但是全局变量存在很多问题，它很容易造成命名空间的污染，也很容易被覆盖。 简单实现单例模式实现一个标准的单例很简单，使用一个变量来标志当前是否已经为某个类创建过对象即可。 1var Singleton = function(name)&#123;2 this.name = name3 // 标志4 this.instance = null5&#125;6Singleton.prototype.getName = function()&#123;7 console.log(this.name)8&#125;9Singleton.getInstance = function(name)&#123;10 if( !this.instance )&#123;11 this.instance = new Singleton(name)12 &#125;13 return this.instance14&#125;15var a = new Singleton.getInstance('a')16var b = new Singleton.getInstance('b')17console.log(a === b) // true 或者把标志和判断都放在一个闭包中实现 1var Singleton = function(name)&#123;2 this.name = name3&#125;4Singleton.prototype.getName = function()&#123;5 console.log(this.name)6&#125;7Singleton.getInstance = (function()&#123;8 var instance = null9 return function(name)&#123;10 if(!this.instance)11 this.instance = new Singleton(name)12 retrun instance13 &#125;14&#125;)() 虽然实现了单例模式，但是上面的代码只是简单说明实现的一个办法，而且缺点也很明显，这里要使用Singleton.getInstance()来获取对象，和使用new XXX()不同。 透明的单例模式对上面的代码进行改进。创建唯一的div节点： 1var createDiv = (function()&#123;2 var instance;3 var Create = function(html)&#123;4 if(instance)&#123;5 return instance6 &#125;7 this.html = html8 this.init()9 return instance = this10 &#125;11 createDiv.prototype.init = function()&#123;12 var div = document.createElement('div')13 div.innerHTML = this.html14 document.bosy.appendChlid(div)15 &#125;16 return Create()17&#125;)();18var a = new CreateDiv('a')19var b = new CreateDiv('b')20console.log(a === b) // true CreateDiv的构造函数，第一创建了对象和执行初始化init方法，第二保证对象只有一个。这个构造函数看起来怪该的，而且如果要将这个类变成普通的类就必须得改造构造函数。 用代理模式实现单例模式先实现简单的类 1var createDiv = function(html)&#123;2 this.html = html3 this.init()4 createDiv.prototype.init = function()&#123;5 var div = document.createElement('div')6 div.innerHTML = this.html7 document.body.appehdChlid(div)8 &#125;9&#125; 引入代理类 1var Proxy= (function()&#123;2 var instance;3 var Create = function()&#123;4 if( !instance)&#123;5 instence = new CreateDiv(html)6 &#125;7 return instance8 &#125;9&#125;)()10var a = new Proxy('a')11var b = new Rpoxy('b')12console.log(a === b) // true 通过这样的组合，我们实现了单例模式。createDiv的类实现数据的初始化和其他方法的实现。Proxy代理类则让创建的类唯一。 惰性单例惰性单例指的是在需要的时候才创建对象实例。上面的例子都是基于‘类’的单例，但是在实际的javascript开发中并不适用。下面以登录浮窗为例，结合全局变量实现惰性单例。 1&lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt;2var createLoginLayer = (function()&#123;3 var div; // 标志4 return function()&#123;5 if ( !div )&#123;6 div = document.createElement( 'div' );7 div.innerHTML = '我是登录浮窗';8 div.style.display = 'none';9 document.body.appendChild( div );10 &#125;11 return div;12 &#125;13&#125;)(); 1415 document.getElementById( 'loginBtn' ).onclick = function()&#123;16 var loginLayer = createLoginLayer();17 loginLayer.style.display = 'block';18 &#125;;19 &lt;/script&gt;20&lt;/html&gt; 通用的惰性单例管理单例的逻辑其实是可以抽出来的。这个逻辑就是：用一个变量来标志是否创建过对象。var obj;if( !obj ){ obj = new XXX;}逻辑抽离实现 1var getSingle = function(fn)&#123;2 var result;3 return function()&#123;4 return result || (result = fn.apply(this,arguments))5 &#125;6&#125; 创建函数 1var Create = function(html,ele)&#123;2 var div = document.createElement(ele)3 div.innerHTML = html4 div.style.display = 'none'5 document.body.appendChlid(div)6 return div7&#125;8// 把创建函数和需要创建的元素传入9var CreateSingle = getSingle(Create，'iframe')10document.getElementById('btn').onclick = function()&#123;11 var iframe = CreateSingle()12 iframe.src = 'XXX'13&#125;","categories":[],"tags":[{"name":"javascript 设计模式","slug":"javascript-设计模式","permalink":"https://cxhai.top/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"函数节流和分时函数","slug":"函数节流和分时函数","date":"2020-01-25T09:19:46.000Z","updated":"2020-01-25T13:53:55.569Z","comments":true,"path":"2020/01/25/函数节流和分时函数/","link":"","permalink":"https://cxhai.top/2020/01/25/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%88%86%E6%97%B6%E5%87%BD%E6%95%B0/","excerpt":"函数节流","text":"函数节流 (1)、函数频繁调用的场景 window.onresize事件。当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常的高。 mousemove事件。 上传进度。(2)、函数节流的原理借助setTimeout()，对函数进行延迟执行。(3)、函数节流的代码实现、实现有许多种，这里主要写一种。1var throttle= function(fn, interval)&#123;2 var _fn = fn, // 保存需要被延迟执行的函数引用3 timer, // 定时器4 firstTime = true; // 是否第一次调用5 return function()&#123;6 var args = arguments,7 _this = this;8 9 if(firstTime)&#123; // 如果是第一次调用，不需要延迟执行10 _fn.apply(_this,args)11 return firstTime = false12 &#125;13 if(timer)&#123; // 如果定时器还在,说明前一次延迟执行还没有完成14 return false15 &#125;16 timer = setTimeout(function()&#123;// 延迟一段时间执行17 clearTimeout(timer);18 timer = null;19 _fn.apply(_this,args)20 &#125;,interval || 500)21 &#125;22&#125;2324window.onresize = throttle(function()&#123;25 console.log(1)26&#125;, 1000) 分时函数一些大量的添加DOM节点的操作显然会让浏览器吃不消。例如：1var arr = []2for (var i =0; i&lt;=1000; i++)&#123;3 arr.push(i)4&#125;5var addDom = function(data)&#123;6 for(var i =0, l=data.lenth; i&lt;l; i++)&#123;7 var div = document.createElement('div')8 div.innerHTML = i9 document.body.appendChild(div)10 &#125;11&#125;12addDom(arr) 浏览器一下子创建1000个节点，我们可以让创建节点分批的进行，比如200毫秒创建10个节点。1/**2 * @description: 3 * @param &#123;Array&#125; arr // 创建节点用到的数据4 * @param &#123;Function&#125; fn // 创建节点函数封装 5 * @param &#123;Number&#125; count // 一次创建的数量 6 * @return: Function7 */8var timeChunk = function(arr,fn,count)&#123;9 var obj,10 timer;11 var len = arr.length;12 var start = function()&#123;13 for(var i=0; i&lt;Math.min(count || 1, len); i++)&#123;14 var obj = arr.shidt();15 fn(obj);16 &#125;17 &#125;18 return function()&#123;19 timer = setInterval(function()&#123;20 if(arr.lenth === 0)&#123;21 return clearInterval(timer)22 &#125;23 start()24 &#125;,200)25 &#125;26&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"高阶函数理解","slug":"高阶函数理解","date":"2020-01-23T05:50:14.000Z","updated":"2020-01-24T09:03:36.009Z","comments":true,"path":"2020/01/23/高阶函数理解/","link":"","permalink":"https://cxhai.top/2020/01/23/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/","excerpt":"说明说说高阶函数。","text":"说明说说高阶函数。 高阶函数高阶函数指的是满足下列条件之一的函数 函数可以作为参数传递 函数可以作为返回值输出一、作为参数传递作为参数传递是，回调函数用的比较多。在ajax异步请求中，回调函数用的很频繁。1var getIUserInfo = function(userId,callback)&#123;2 $.ajax('http://xxx.com/getUserInfo?' + userId, function(data)&#123;3 if(typeof callback === \"Function\") &#123;4 callback(data)5 &#125; 6 &#125;)7&#125; 又比如数组的排序函数，sort()默认排序是把字符转为unicode码值进行比较，很多时候需要自定义排序规则。1[1,2,4,6,3,].sort(function(a,b)&#123;2 return a-b // 从小到大3 // return b-a 从大到小4&#125;) 作为返回值输出这里拿判断数据来举个栗子：1var isString = function(obj)&#123;2 return Object.prototype.toString.call(obj) === '[Object String]'3&#125;;4var isArray = function(obj)&#123;5 return Object.prototype.toString.call(obj) === '[Object Array]'6&#125;7var isNumber = function(obj)&#123;8 return Object.prototype.toString.call(obj) === '[Object Number]'9&#125;10// 可以看出大部分代码都是相同的11// 我们进行一个封装12var isType = funciton(type)&#123;13 // 函数作为返回值14 return function(obj)&#123;15 return Object.prototype.toString.call(obj) === '[Object'+ type + ']' 16 &#125;17&#125; 高阶函数实现AOPAOP(面向切面编程)的主要作用是把一些跟核心业务无关的功能抽离出来。通过Function.prototype实现。 1Function.prototype.before = function(beforefn)&#123;2 var _self = this3 return function()&#123;4 beforefn.apply(this,arguments) // 执行beforefn()5 return _self.apply(this,arguments); // 执行原函数6 &#125;7&#125;8Function.prototype.after = function(afterfn)&#123;9 var _self = this;10 return function()&#123;11 var result = _self.apply(this, arguments)12 afterfn.apply(this,arguments)13 return result14 &#125;15&#125;16var func = function()&#123;17 console.log('2')18&#125;19func = func.before(function()&#123;20 console.log('1')21&#125;).after(function()&#123;22 console.log('3')23&#125;)24func() // 1 2 3 这样就动通过AOP的方式，动态的向func()函数植入打印1和打印3的函数。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"关于闭包","slug":"关于闭包","date":"2020-01-19T15:06:34.000Z","updated":"2020-01-23T05:47:35.532Z","comments":true,"path":"2020/01/19/关于闭包/","link":"","permalink":"https://cxhai.top/2020/01/19/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/","excerpt":"说明闭包是一个难懂又必须搞懂的概念。这里结合变量作用域来说明闭包的概念。","text":"说明闭包是一个难懂又必须搞懂的概念。这里结合变量作用域来说明闭包的概念。 作用域的理解，主要针对es5，不涉及ES6。 变量作用域变量作用域指变量的有效范围。对于javascript的作用域，这里做一个概述。 一、“javascript无块级作用域”（es5）,（es6引入let关键字，用于指定变量的作用域）二、js采用函数作用域在js中函数即作用域，在外部无法访问函数内部作用域的变量。 1function func()&#123;2 var inner = 'inner'3&#125;4func();5console.log(inner) // 报错 三、JavaScript的作用域链由于js采用函数作用域，那么出现嵌套函数时，就会出现作用域链。 1var ex = 'outerWin'2function Func()&#123;3 var ex = 'inner'4 function innerFunc()&#123;5 var ex = 'innerFun'6 console.log(ex)7 &#125;8 innerFunc()9&#125;10Func() 上面代码出现了三个作用域，全局作用域》Func()》innerFunc(),寻找ex变量时，会沿着作用域链，从内（当前变量所在作用域）往外找，如果都没有这个变量，则抛出异常。 四、javascript的作用域链执行前已创建javascript的作用域在被执行之前已经创建，之后再执行会按照作用域去寻找。 1var ex = 'outerWin'2function Func()&#123;3 var ex = 'inner'4 function innerFunc()&#123;5 console.log(ex)6 &#125;7 return innerFunc8&#125;9var result = Func()10result() // inner 在result()调用之前，作用域链已经存在。全局作用域-&gt;Func()作用域-&gt;innerFunc()作用域执行result()时，result指代的是innerFunc()函数，innerFunc()的作用域并没有ex这个变量，那么找到Func()作用域，找到，那么输出ex。再看看下面的这个例子: 1var ex = 'outerWin'2function Bar()&#123;3 console.log(ex)4&#125;5function Foo()&#123;6 var foo = 'foo'7 return Bar8&#125;9var result = Foo()10result() //outerWin 这段代码在执行前，创建了两条作用域链:全局作用域-&gt;Bar()作用域全局作用域-&gt;Foo()作用域执行result()时，result指代Bar()函数，那么在Bar()函数里面寻找变量。 五、声明提前javascript的函数在被执行之前，会将其中的变量全部声明，而不赋值。 1function Func()&#123;2 console.log(x)3 var x = 14&#125;5Func() // undefined6// 上面写法相当于7function Func()&#123;8 var x;9 console.log(x)10 x = 111&#125;12Func() 闭包按理，一个函数执行完，退出，那么函数内部的局部变量会被销毁。我们对上面的第四点时的代码做修改， 1var func = function()&#123;2 var a = 1;3 return function()&#123;4 a++;5 console.log(a)6 &#125;7&#125;8var f = func()9f() // 210f() // 3 结合上面的作用域链，我们可以理解第一次执行f()，输出2，函数执行结束，变量a应该销毁了才对，但是后面继续执行为什么会输出3？因为当执行 var f = func() 时，f返会一个匿名函数的引用，它可以访问到func()被调用时产生的环境（也叫上下文，有新的函数执行都会产生一个新的上下文，这个上下文决定了我们可以访问到哪些变量，函数等），既然调用f()就可以访问函数的上下文，那么自然可以访问到a变量。可见闭包是将函数内部和函数外部连接的桥梁，简单理解就是，闭包是能够读取其他函数内部变量的函数。 闭包的弊端简单概括的话，会造成内存泄漏。但单单是从占用内存这方面来说，变量放在闭包和全局作用域下，对内存的影响是一致的，不能说成内存泄漏。闭包和内存泄漏的地方是：使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这时候就有可能造成内存泄漏。解决办法：将循环引用的变量设置为null即可。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"call()和apply的用途","slug":"artitle4","date":"2020-01-18T15:16:54.000Z","updated":"2020-01-19T15:07:03.990Z","comments":true,"path":"2020/01/18/artitle4/","link":"","permalink":"https://cxhai.top/2020/01/18/artitle4/","excerpt":"说明说说call()和apply()在实际开发中的用途。","text":"说明说说call()和apply()在实际开发中的用途。 一、改变this的指向call()和apply()最常用的是改变函数内部的this指向。 1var obj1 = &#123;2 name: 'obj1'3&#125;4var obj2 = &#123;5 name: 'obj2'6&#125;7window.name = 'win'8var getName = function()&#123;9 console.log(this.name)10&#125;11getName() // win12getName.call(obj1) // obj113getName.apply(obj2) // obj214// call()和apply()的主要区别在于传入多个参数时的传参形式。 在实际开发中，经常会遇到this指向被不经意改变场景。例如： 1doucument.getElementById('div1').onclick = function()&#123;2 alert(this.id) // div13 var func = function()&#123;4 alert(this.id) 5 &#125;6 func() // undefined7 func.call(this); // div18&#125; 二、Function.prototype.bind大部分高级浏览器都实现了内置的Function.prototype.bind,用来指定函数内部的this指向。语法: fun.bind(this,arg1,arg2…)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用。模拟实现bind(): 1Function.prototype.bind = function(context)&#123;2 var self = this; // 这时候this指向func3 // bind() 返回的是一个函数4 return function()&#123; // 返回一个新的函数5 return self.apply(context,arguments) 6 &#125;7&#125;8var obj = &#123;9 name: 'obj'10&#125;11var func = function()&#123;12 console.log(this.name)13&#125;.bind(obj) // 相当于func.bind()14// 因此, var self = this, 中的this指向func()15// 那么执行func.bind() 将获得bind()的返回函数16func() // obj17// func() 即是执行返回函数 self.apply(context，arguments),即是func.apply(...),相当于执行自身 上面是简单版的bind()实现，通常我们会像下面这样实现: 1Function.prototype.bind = function()&#123;2 var self = this,3 // shift()删除数组的第一个元素，并返回被删除元素4 context = [].shift.call(arguments)5 // 通过slice()将剩余参数转为数组6 args = [].slice.call(arguments)7 return function()&#123;8 return self.apply(context, [].concat.call(args, [].slice.call(arguments)))9 // 两次调用可能都会传入参数，需要做参数整合10 &#125;11&#125;1213var obj = &#123;14 name: 'obj'15&#125;16var func = function(a,b,c,d)&#123;17 console.log(this.name)18 console.log([a,b,c,d])19&#125;.bind(obj,1,2) // 第一次bind()传入2021func(3,4) // [1,2,3,4] // 第二次func()传入 三、借用其他对象的方法借用的第一种场景是”借用构造函数”，可以实现类似继承的效果: 1var A = function(name)&#123;2 this.name = name3&#125;4var B = function ()&#123;5 A.apply(this, arguments)6&#125;7B.prototype.getName = function()&#123;8 return this.name9&#125;10var b = new B('b')11console.log(b.getName()) // b 借用场景二arguments的灵活使用:函数的arguments是一个类数组对象。类数组对象: 和数组一样有下标，但是没有数组的方法，不能进行排序操作或者添加元素等。 1(function()&#123;2 Array.prototype.push.call(arguments, 3);3 console.log(arguments); // 输出[1,2,3]4&#125;)(1,2)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"javascript的this指向","slug":"artitle3","date":"2020-01-17T12:16:18.000Z","updated":"2020-01-18T14:34:07.260Z","comments":true,"path":"2020/01/17/artitle3/","link":"","permalink":"https://cxhai.top/2020/01/17/artitle3/","excerpt":"说明记录一些关于this指向的知识。","text":"说明记录一些关于this指向的知识。 this的指向 作为对象的方法调用， this指向该调用对象 1var obj = &#123;2 a:1,3 func:function()&#123;4 console.log(this === obj) // true5 console.log(this.a) // 16 &#125;7&#125;8obj.func()910// 注意：11var x = obj.func // 把函数体拉到外面，12x() // 相当于作为普通函数，在window下直接调用，this指向window 作为普通函数调用（直接调用，不作为对象的属性被调用,this指向全局对象。浏览器中this为window,node中为global) 1var a = 1;2var aa = function()&#123;3 console.log(this);4 console.log(this.a);5&#125;6aa() // 输出window和1 *注意，在strict模式下，直接调用this已经视为undefined。 构造函数调用（new操作）， this指向返回的这个对象 1var A = function()&#123;2 this.a = 13 console.log(this.a)4&#125;5var obj = new A() // 1 *注意，如果构造函数显式的返回对象，返回对象（返回其他类型会被忽略），那么构造函数中使用this初始化的变量没有意义。 1// 显式返回对象2var A = function()&#123;3 this.a = 14 return &#123;5 a: 36 &#125;7&#125;8var a = new A()9console.log(a.a) // 3 这里简单说一下new的过程 1.创建一个空的Object对象，var obj = new Object() 2.将构造函数中的this指向刚创建的obj对象 3.将创建的obj的proto指向构造函数的prototype。 4.执行构造函数中的代码 call(),apply(),bind()调用 call()和apply()的作用基本相同的，都是更改对象的内部指针，即改变对象的this指向。它们主要的区别是传入参数形式不同。当函数需要传递多个变量时，call()接受一系列的单独变量，apply()接受一个数组(array)作为参数。call(obj,arg1,arg2…) apply(obj,[arg1,arg2…]) *注意：当第一个参数存入undefined、null时，默认指向window 1var obj1 = &#123;2 name:'obj1',3 getName:function()&#123;4 return this.name5 &#125;6&#125;7var obj2 = &#123;8 name: 'obj2'9&#125;10console.log(obj1.getName()) // obj111console.log(obj1.getName.call(obj2)) // obj2 bind()的使用和call()差不多，区别是bind()返回的是函数以及bind()接受的参数列表的使用bind()方法不会立即执行，而是返回一个改变上下文this后的函数。而原函数中的this并没有改变。1var obj = &#123;2 name: 'obj'3&#125;4function printName()&#123;5 console.log(this.name)6&#125;7var func = printName.bind(obj)8console.log(func) // function()&#123;...&#125;9func() // obj ES6箭头函数this指向默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）;即使是call，apply，bind等方法也不能改变箭头函数this的指向。箭头函数实例：1var obj = &#123;2 num: 10,3 func: function()&#123;4 console.log(this) ; // obj5 setTimeout(() =&gt; &#123;6 console.log(this) // obj7 &#125;)8 &#125;,9 func1: () =&gt; &#123;console.log(this)&#125; // window10&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"prototype和__proto__","slug":"artitle2","date":"2020-01-15T12:33:40.000Z","updated":"2020-01-15T14:26:27.145Z","comments":true,"path":"2020/01/15/artitle2/","link":"","permalink":"https://cxhai.top/2020/01/15/artitle2/","excerpt":"说明搞懂jascript的prototype和proto。","text":"说明搞懂jascript的prototype和proto。 在javascript中，根对象为Object.prototype。在js遇到的所有对象，实际上都是从Object.prototype克隆而来的，Object.prototype对象就是所有对象的原型。看看下面的代码: 1let obj1 = new Object();2let obj2 = &#123;&#125;3console.log(Object.getPrototype(obj1) === Object.prototype) // true4console.log(Object.getPrototype(obj2) === Object.prototype) // true因此在创建对象or函数的时候，会有一些自定义的属性， 定义函数的时候，预定义属性就是prototype,而这个prototype是一个普通的对象。 定义普通对象or实例化对象的时候，预定义的属性是proto(不会有prototype这个属性),这个proto指向的是这个object的constructor的prototype。 定义函数时控制台试试下面的代码: 1// 定义函数时2let objFactory = function()&#123;&#125;3console.log(objFactory.prototype) 4//这个prototype对象包含constructor（指向函数本身）和__proto__(对象都有这个属性),刚才说的proto指向对象的构造函数的prtotype。那么objFactory.prototype这个对象的构造函数是什么呢？ 所有的对象都是基于Object.prototype,所以objFactory.prototype这个对象的构造函数就是Object.prototype控制台试试下面的代码: 1console.log(objFactory.prototype.__proto__)2console.log(Object.prototype)3// 它们打印出来的是同一个东西。 因此，也可以说Object.prototype是所有函数的爸爸，声明一个函数的时候也就相当于对Object的实例化。 定义或者实例对象时实例化对象 1let obj = new objFactory()2console.log(obj) 可以看到没有obj中没有prototype这个属性console.log(obj.prototype) // undefined而proto指向对象的构造函数的prototype 1console.log(b.__proto__=== B.prototype) // true 这就是prototype和proto的区别。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"hexo+githubPage搭建个人博客","slug":"artitle1","date":"2019-12-13T16:00:00.000Z","updated":"2019-12-14T13:04:35.462Z","comments":true,"path":"2019/12/14/artitle1/","link":"","permalink":"https://cxhai.top/2019/12/14/artitle1/","excerpt":"说明 搭建个人博客已经好几天了,还没有写过文章，这里主要转载别人的几篇文章，教程很详细，想要搭建个人博客网站的可以看看！","text":"说明 搭建个人博客已经好几天了,还没有写过文章，这里主要转载别人的几篇文章，教程很详细，想要搭建个人博客网站的可以看看！ 入门使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 页面美化Hexo 博客优化之博客美化系列 实用功能添加Hexo 博客优化之实用功能添加系列 自定义页面hexo的模板，新建一个页面默认都是嵌入到模板中的，如果想要自己写一个页面也是ok的。Hexo 博客自定义一个不使用主题模板渲染的独立页面 搭建图床如果用于展示图片的话，建议搭建图床，这样在页面通过连接加载图片资源就可以了。Github+jsDelivr+PicGo 打造稳定快速、高效免费图床 总结本人也是一路跟着教程，一步步的走下来，也遇过不少坑。 坑一右下角的动画人物，我第一次尝试着弄一个，成功之后就修改不了了，只能控制显示和隐藏，修改配置文件，甚至把动画人物插件删除都不管用，至今未解决。 坑二域名添加了github地址后，不要急着使用域名访问网页，等个10分钟这样。我当时瞎搞了一两个小时，怎么都访问不了，睡醒就可以通过域名访问了。频繁的修改域名解释，可能会弄坏域名。 坑三不蒜子以前的资源网站已过期，一些模板可能没有更新js资源地址，手动替代模板中的资源路径即可 坑四gitment评论系统，不同的浏览器要登录一遍才可以评论，查了下说可以使用nigx代理解决。如果在搭建的过程中遇到了问题，可以私信我，一起探讨。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cxhai.top/tags/hexo/"},{"name":"gitPage","slug":"gitPage","permalink":"https://cxhai.top/tags/gitPage/"}]}]}