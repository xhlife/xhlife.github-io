{"meta":{"title":"cxhai-blog","subtitle":"","description":"","author":"cxh","url":"https://cxhai.top","root":"/"},"pages":[{"title":"","date":"2020-02-06T13:44:41.392Z","updated":"2020-02-06T13:44:41.392Z","comments":true,"path":"about/index.html","permalink":"https://cxhai.top/about/index.html","excerpt":"","text":"其实我是来讨打赏的！"}],"posts":[{"title":"css一些动画效果","slug":"css动画","date":"2020-02-07T04:58:17.000Z","updated":"2020-02-08T07:20:58.741Z","comments":true,"path":"2020/02/07/css动画/","link":"","permalink":"https://cxhai.top/2020/02/07/css%E5%8A%A8%E7%94%BB/","excerpt":"说明记录一些css动画特效，交错动画，文字特效，按钮特效等,主要是animation(动画),transition(过渡)和伪类的应用。","text":"说明记录一些css动画特效，交错动画，文字特效，按钮特效等,主要是animation(动画),transition(过渡)和伪类的应用。 @import url(https://fonts.googleapis.com/css?family=Lato); /* 交错动画 */ .loading { display: flex; justify-content: center; align-items: center; } .loading .dot { position: relative; width: 2em; height: 2em; margin: 0.8em; border-radius: 50%; } .loading .dot::before { position: absolute; content: \"\"; width: 100%; height: 100%; background: inherit; border-radius: inherit; animation: wave 2s ease-out infinite; } .loading .dot:nth-child(1) { background: #003333; } .loading .dot:nth-child(1)::before { animation-delay: 0.2s; } .loading .dot:nth-child(2) { background: #006600; } .loading .dot:nth-child(2)::before { animation-delay: 0.4s; } .loading .dot:nth-child(3) { background: #009900; } .loading .dot:nth-child(3)::before { animation-delay: 0.6s; } .loading .dot:nth-child(4) { background: #00bb00; } .loading .dot:nth-child(4)::before { animation-delay: 0.8s; } .loading .dot:nth-child(5) { background: #00ff00; } .loading .dot:nth-child(5)::before { animation-delay: 1s; } @keyframes wave { 50%, 75% { transform: scale(2.5); } 80%, 100% { opacity: 0; } } /* 文字交错-特效一 */ .char{ display: flex; flex-wrap: wrap; font-size: 20px; color: greenyellow; font-family: Lora, serif; white-space: pre; } .char span { animation: landIn 3s ease-out infinite; } @keyframes landIn { 0% { opacity: 0; transform: translateY(-20%); } 100% { opacity: 1; transform: translateY(0); } } /* 文字交错-特效二 */ .father{ position: relative; width: 320px; margin-left: 30px; } .reveal{ position: relative; display: flex; color: #6ee1f5; font-size: 2em; font-family: Raleway, sans-serif; letter-spacing: 3px; text-transform: uppercase; white-space: pre; } .reveal::before, .reveal::after{ position: absolute; content: \"\"; top: 0; bottom: 0; width: 2px; height: 100%; background: white; opacity: 0; transform: scale(0); } .reveal span { opacity: 0; transform: scale(0); animation: fadeIn 2.4s infinite; } .reveal::before, .reveal::after { position: absolute; content: \"\"; top: 0; bottom: 0; width: 2px; height: 100%; background: red; opacity: 0; transform: scale(0); } .reveal::before { left: 50%; animation: slideLeft 2s cubic-bezier(0.7, -0.6, 0.3, 1.5) forwards; } .reveal::after { right: 50%; animation: slideRight 2s cubic-bezier(0.7, -0.6, 0.3, 1.5) forwards; } @keyframes fadeIn { to { opacity: 1; transform: scale(1); } } @keyframes slideLeft { to { left: -6%; opacity: 1; transform: scale(0.9); } } @keyframes slideRight { to { right: -6%; opacity: 1; transform: scale(0.9); } } /* 文字交错-特效三 */ .float-text-menu { display: flex; flex-direction: column; list-style-type: none; } .float-text-menu p a { display: flex; padding: 6px; color: white; font-family: Lato, sans-serif; text-decoration: none; overflow: hidden; } .float-text-menu p a span { position: relative; transition: 0.3s; } .float-text-menu p a span::before { position: absolute; content: attr(data-text); transform: translateY(130%); } .float-text-menu p a:hover span { transform: translateY(-130%); } /* 按钮特效一 */ .btn { --hue: 190; --ease-in-duration: 0.25s; --ease-out-duration: 0.65s; --ease-out-delay: var(--ease-in-duration); position: relative; padding: 1rem 3rem; font-size: 1rem; line-height: 1.5; color: white; text-decoration: none; background-color: hsl(var(--hue), 100%, 41%); border: 1px solid hsl(var(--hue), 100%, 41%); outline: transparent; overflow: hidden; cursor: pointer; user-select: none; white-space: nowrap; transition: 0.25s; } .btn:hover { background: hsl(var(--hue), 100%, 31%); } .btn-primary { --hue: 171; } .btn-ghost { color: hsl(var(--hue), 100%, 41%); background-color: transparent; border-color: hsl(var(--hue), 100%, 41%); } .btn-ghost:hover { color: white; } .btn-border-stroke { border-color: hsla(var(--hue), 100%, 41%, 0.35); } .btn-border-stroke .btn-borders { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } .btn-border-stroke .btn-borders .border-top { position: absolute; top: 0; width: 100%; height: 1px; background: hsl(var(--hue), 100%, 41%); transform: scaleX(0); transform-origin: left; } .btn-border-stroke .btn-borders .border-right { position: absolute; right: 0; width: 1px; height: 100%; background: hsl(var(--hue), 100%, 41%); transform: scaleY(0); transform-origin: bottom; } .btn-border-stroke .btn-borders .border-bottom { position: absolute; bottom: 0; width: 100%; height: 1px; background: hsl(var(--hue), 100%, 41%); transform: scaleX(0); transform-origin: left; } .btn-border-stroke .btn-borders .border-left { position: absolute; left: 0; width: 1px; height: 100%; background: hsl(var(--hue), 100%, 41%); transform: scaleY(0); transform-origin: bottom; } .btn-border-stroke .btn-borders .border-left { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn-border-stroke .btn-borders .border-bottom { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn-border-stroke .btn-borders .border-right { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn-border-stroke .btn-borders .border-top { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn-border-stroke:hover { color: hsl(var(--hue), 100%, 41%); background: transparent; } .btn-border-stroke:hover .border-top, .btn-border-stroke:hover .border-bottom { transform: scaleX(1); } .btn-border-stroke:hover .border-left, .btn-border-stroke:hover .border-right { transform: scaleY(1); } .btn-border-stroke:hover .border-left { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn-border-stroke:hover .border-bottom { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn-border-stroke:hover .border-right { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn-border-stroke:hover .border-top { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn-text-float-up::after { position: absolute; content: attr(data-text); top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; opacity: 0; transform: translateY(35%); transition: 0.25s ease-out; } .btn-text-float-up .btn-text { display: block; transition: 0.75s 0.1s cubic-bezier(0.2, 1, 0.2, 1); } .btn-text-float-up:hover .btn-text { opacity: 0; transform: translateY(-25%); transition: 0.25s ease-out; } .btn-text-float-up:hover::after { opacity: 1; transform: translateY(0); transition: 0.75s 0.1s cubic-bezier(0.2, 1, 0.2, 1); } /* 多重边框 */ .btn1 { --hue: 190; --ease-in-duration: 0.25s; --ease-out-duration: 0.65s; --ease-out-delay: var(--ease-in-duration); position: relative; padding: 1rem 3rem; font-size: 1rem; line-height: 1.5; color: white; text-decoration: none; background-color: hsl(var(--hue), 100%, 41%); border: 1px solid hsl(var(--hue), 100%, 41%); outline: transparent; cursor: pointer; user-select: none; white-space: nowrap; transition: 0.25s; } .btn1:hover { background: hsl(var(--hue), 100%, 31%); } .btn1-primary { --hue: 171; } .btn1-ghost { color: hsl(var(--hue), 100%, 41%); background-color: transparent; border-color: hsl(var(--hue), 100%, 41%); } .btn1-ghost:hover { color: white; } .btn1-multiple-border-stroke { border-color: transparent; } .btn1-multiple-border-stroke .btn1-borders-group { position: absolute; top: 0; left: 0; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; border: 1px solid hsla(var(--hue), 100%, 41%, 0.35); } .btn1-multiple-border-stroke .btn1-borders-group:nth-child(1) { left: -8px; padding: 0 8px; } .btn1-multiple-border-stroke .btn1-borders-group:nth-child(2) { top: -8px; padding: 8px 0; } .btn1-multiple-border-stroke .btn1-borders-group:nth-child(3) { top: -4px; left: -4px; padding: 4px; } .btn1-multiple-border-stroke .btn1-borders-group .border1-top { position: absolute; top: 0; width: 100%; height: 1px; background: hsl(var(--hue), 100%, 41%); transform: scaleX(0); transform-origin: left; } .btn1-multiple-border-stroke .btn1-borders-group .border1-right { position: absolute; right: 0; width: 1px; height: 100%; background: hsl(var(--hue), 100%, 41%); transform: scaleY(0); transform-origin: bottom; } .btn1-multiple-border-stroke .btn1-borders-group .border1-bottom { position: absolute; bottom: 0; width: 100%; height: 1px; background: hsl(var(--hue), 100%, 41%); transform: scaleX(0); transform-origin: left; } .btn1-multiple-border-stroke .btn1-borders-group .border1-left { position: absolute; left: 0; width: 1px; height: 100%; background: hsl(var(--hue), 100%, 41%); transform: scaleY(0); transform-origin: bottom; } .btn1-multiple-border-stroke .btn1-borders-group .border1-left { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn1-multiple-border-stroke .btn1-borders-group .border1-bottom { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn1-multiple-border-stroke .btn1-borders-group .border1-right { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn1-multiple-border-stroke .btn1-borders-group .border1-top { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn1-multiple-border-stroke:hover { color: hsl(var(--hue), 100%, 41%); background: transparent; } .btn1-multiple-border-stroke:hover .border1-top, .btn1-multiple-border-stroke:hover .border1-bottom { transform: scaleX(1); } .btn1-multiple-border-stroke:hover .border1-left, .btn1-multiple-border-stroke:hover .border1-right { transform: scaleY(1); } .btn1-multiple-border-stroke:hover .border1-left { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn1-multiple-border-stroke:hover .border1-bottom { transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0); } .btn1-multiple-border-stroke:hover .border1-right { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } .btn1-multiple-border-stroke:hover .border1-top { transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1); } /* 按钮光影 */ .btn2 { --hue: 190; position: relative; padding: 1rem 3rem; font-size: 1rem; line-height: 1.5; color: white; text-decoration: none; text-transform: uppercase; background-color: hsl(var(--hue), 100%, 41%); border: 1px solid hsl(var(--hue), 100%, 41%); outline: transparent; overflow: hidden; cursor: pointer; user-select: none; white-space: nowrap; transition: 0.25s; } .btn2:hover { background: hsl(var(--hue), 100%, 31%); } .btn2-primary { --hue: 187; } .btn2-ghost { color: hsl(var(--hue), 100%, 41%); background-color: transparent; border-color: hsl(var(--hue), 100%, 41%); } .btn2-ghost:hover { color: white; } .btn2-shine { color: white; } .btn2-shine::before { position: absolute; content: \"\"; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(120deg, transparent, hsla(var(--hue), 100%, 41%, 0.5), transparent); transform: translateX(-100%); transition: 0.6s; } .btn2-shine:hover { background: transparent; box-shadow: 0 0 20px 10px hsla(var(--hue), 100%, 41%, 0.5); } .btn2-shine:hover::before { transform: translateX(100%); } /* 代办事情列表 */ .todo-list { display: -webkit-box; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; flex-direction: column; padding: 0 75px 10px 30px; background: #162740; border: transparent; } .todo-list .todo-list_title{ padding: 3px 6px; color: #f1faee; background-color: #264456; } .todo-list .todo-list_label{ display: -webkit-box; display: flex; -webkit-box-align: center; align-items: center; margin: 40px 0; font-size: 24px; font-family: Lato, sans-serif; color: #f1faee; cursor: pointer; } .todo-list .todo-list_label input[type=\"checkbox\"] { opacity: 0; -webkit-appearance: none; -moz-appearance: none; appearance: none; } .todo-list .todo-list_label input[type=\"checkbox\"] + .check { position: absolute; width: 25px; height: 25px; border: 2px solid #f1faee; -webkit-transition: 0.2s; transition: 0.2s; } .todo-list .todo-list_label input[type=\"checkbox\"]:checked + .check { width: 25px; height: 15px; border-top: transparent; border-right: transparent; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); } .todo-list .todo-list_label input[type=\"checkbox\"] ~ span { position: relative; left: 40px; white-space: nowrap; -webkit-transition: 0.5s; transition: 0.5s; } .todo-list .todo-list_label input[type=\"checkbox\"] ~ span::before { position: absolute; content: \"\"; top: 50%; left: 0; width: 100%; height: 1px; background: #f1faee; -webkit-transform: scaleX(0); transform: scaleX(0); -webkit-transition: -webkit-transform 0.5s; transition: -webkit-transform 0.5s; transition: transform 0.5s; transition: transform 0.5s, -webkit-transform 0.5s; } .todo-list .todo-list_label input[type=\"checkbox\"]:checked ~ span { color: #585b57; } .todo-list .todo-list_label input[type=\"checkbox\"]:checked ~ span::before { -webkit-transform: scaleX(1); transform: scaleX(1); } /* 内发光效果 */ .loading1 { position: relative; width: 8em; height: 8em; background: black; border-radius: 50%; box-shadow: inset 0.5em -0.5em crimson; animation: spin 2s linear infinite; } .loading1::before, .loading1::after { position: absolute; content: \"\"; width: 100%; height: 100%; background: rgb(10, 10, 10); border-radius: inherit; box-shadow: inherit; } .loading1::before { filter: blur(5px); } .loading1::after { filter: blur(10px); } @keyframes spin { to { transform: rotate(1turn); } } 一、交错动画效果如下： 主要用到css动画的delay属性。主要代码： 1&lt;style&gt;2 /* 容器 */3.con &#123;4 display: flex;5 justify-content: center;6 align-items: center;7&#125;8 /* 圆点 */9.con .dot &#123;10 position: relative;11 width: 2em;12 height: 2em;13 margin: 0.8em;14 border-radius: 50%;15&#125;1617.con .dot::before &#123;18 position: absolute;19 content: \"\";20 width: 100%;21 height: 100%;22 background: inherit;23 border-radius: inherit;24 animation: wave 2s ease-out infinite;25 /* animation属性26 animation: 名字 时长 速度曲线 延迟时间 动画次数 方向27 infinite:无限播放 28 */29&#125;30/* 第一个点 */31.con .dot:nth-child(1) &#123;32 background: #003300;33&#125;3435.con .dot:nth-child(1)::before &#123;36 animation-delay: 0.2s;37&#125;38/* 以此类推其余点的样式的样式 */39/* 动画 */40@keyframes wave &#123;41 50%, 75% &#123;42 transform: scale(2.5);43 &#125;44 80%, 100% &#123;45 opacity: 0;46 &#125;47&#125;48&lt;/style&gt; 二、文本特效动画一： abcd efgh ijkl mnop qrst uvws yz window.onload = function(){ // 文字效果一 var Texts = document.querySelectorAll(\".char\"); Texts.forEach(function (Text) { var letters1 = Text.textContent.split(\"\"); Text.textContent = \"\"; letters1.forEach(function (letter, i) { var span = document.createElement(\"span\"); span.textContent = letter; span.style.animationDelay = i * 0.05 + \"s\"; Text.append(span); }); }); // 文字效果二 var duration = 0.8; var delay = 0.3; var revealText = document.querySelector(\".reveal\"); var letters2 = revealText.textContent.split(\"\"); revealText.textContent = \"\"; var middle = letters2.filter(function (e) { return e !== \" \"; }).length / 2; letters2.forEach(function (letter, i) { var span = document.createElement(\"span\"); span.textContent = letter; span.style.animationDelay = delay + Math.abs(i - middle) * 0.1 + \"s\"; revealText.append(span); }); // 文字效果三 var floatTextMenuLinks = document.querySelectorAll(\".float-text-menu p a\"); floatTextMenuLinks.forEach(function (link) { var letters3 = link.textContent.split(\"\"); link.textContent = \"\"; letters3.forEach(function (letter, i) { var span = document.createElement(\"span\"); span.textContent = letter; span.style.transitionDelay = i / 20 + \"s\"; span.dataset.text = letter; link.append(span); }); }); } 主要代码： 1&lt;style&gt;2.char&#123;3 display: flex;4 flex-wrap: wrap;5 font-size: 20px;6 color: greenyellow;7 font-family: Lora, serif;8 white-space: pre;9&#125;10.char span &#123;11 animation: landIn 0.8s ease-out both;12&#125;13@keyframes landIn &#123;14 0% &#123;15 opacity: 0;16 transform: translateY(-20%);17 &#125;18 100% &#123;19 opacity: 1;20 transform: translateY(0);21 &#125;22&#125;23&lt;/style&gt;24&lt;p class=\"char\"&gt;abcd efgh ijkl mnop qrst uvws yz&lt;/p&gt;25&lt;script&gt;26 window.onload = function()&#123;27 var Texts = document.querySelectorAll(\".char\");28 Texts.forEach(function (Text) &#123;29 var letters = Text.textContent.split(\"\");30 Text.textContent = \"\";31 letters.forEach(function (letter, i) &#123;32 var span = document.createElement(\"span\");33 span.textContent = letter;34 // 通过下标值 i 来实现延迟35 span.style.animationDelay = i * 0.05 + \"s\";36 Text.append(span);37 &#125;);38 &#125;);39 &#125;40&lt;/script&gt; 效果二: welcome to css 主要代码： 1&lt;div class=\"father\"&gt;2 &lt;div class=\"reveal\"&gt;welcome to css&lt;/div&gt;3&lt;/div&gt;45&lt;style&gt;6.father&#123;7 position: relative;8 width: 320px;9 margin-left: 30px;10&#125;11.reveal&#123;12 position: relative;13 display: flex;14 color: #6ee1f5;15 font-size: 2em;16 font-family: Raleway, sans-serif;17 letter-spacing: 3px;18 text-transform: uppercase;19 white-space: pre;20&#125;21.reveal::before, .reveal::after&#123;22 position: absolute;23 content: \"\";24 top: 0;25 bottom: 0;26 width: 2px;27 height: 100%;28 background: white;29 opacity: 0;30 transform: scale(0);31&#125;32.reveal span &#123;33 opacity: 0;34 transform: scale(0);35 animation: fadeIn 2.4s infinite;36&#125;37.reveal::before, .reveal::after &#123;38 position: absolute;39 content: \"\";40 top: 0;41 bottom: 0;42 width: 2px;43 height: 100%;44 background: red;45 opacity: 0;46 transform: scale(0);47&#125;48.reveal::before &#123;49 left: 50%;50 animation: slideLeft 2s cubic-bezier(0.7, -0.6, 0.3, 1.5) forwards;51&#125;52.reveal::after &#123;53 right: 50%;54 animation: slideRight 2s cubic-bezier(0.7, -0.6, 0.3, 1.5) forwards;55&#125;5657@keyframes fadeIn &#123;58 to &#123;59 opacity: 1;60 transform: scale(1);61 &#125;62&#125;63@keyframes slideLeft &#123;64 to &#123;65 left: -6%;66 opacity: 1;67 transform: scale(0.9);68 &#125;69&#125;70@keyframes slideRight &#123;71 to &#123;72 right: -6%;73 opacity: 1;74 transform: scale(0.9);75 &#125;76&#125;77&lt;/style&gt;78&lt;script&gt;79 var duration = 0.8;80 var delay = 0.3;81 var revealText = document.querySelector(\".reveal\");82 var letters2 = revealText.textContent.split(\"\");83 revealText.textContent = \"\";84 var middle = letters2.filter(function (e) &#123; return e !== \" \"; &#125;).length / 2;85 letters2.forEach(function (letter, i) &#123;86 var span = document.createElement(\"span\");87 span.textContent = letter;88 // 从中间开始往两边延迟 (i-middle), 偏差越大延迟越久89 span.style.animationDelay = delay + Math.abs(i - middle) * 0.1 + \"s\";90 revealText.append(span);91 &#125;);92&lt;/script&gt; 效果三： Home Archives Tags Categories About 三、按钮特效鼠标悬浮-动态边框，效果如下： Hover Button 主要代码： 1&lt;div style=\"display:flex;width:100%;justify-content: center;align-items: center;\"&gt;2 &lt;button data-text=\"Button\" class=\"btn btn-primary btn-ghost btn-border-stroke btn-text-float-up\"&gt;3 &lt;div class=\"btn-borders\"&gt;4 &lt;div class=\"border-top\"&gt;&lt;/div&gt;5 &lt;div class=\"border-right\"&gt;&lt;/div&gt;6 &lt;div class=\"border-bottom\"&gt;&lt;/div&gt;7 &lt;div class=\"border-left\"&gt;&lt;/div&gt;8 &lt;/div&gt;9 &lt;span class=\"btn-text\"&gt;Button&lt;/span&gt;10 &lt;/button&gt;11&lt;/div&gt;1213&lt;style&gt;14.btn &#123;15 --hue: 190;16 --ease-in-duration: 0.25s;17 --ease-out-duration: 0.65s;18 --ease-out-delay: var(--ease-in-duration);19 position: relative;20 padding: 1rem 3rem;21 font-size: 1rem;22 line-height: 1.5;23 color: white;24 text-decoration: none;25 /* hsl(色相(0-360)，饱和度，明度) */26 background-color: hsl(var(--hue), 100%, 41%);27 border: 1px solid hsl(var(--hue), 100%, 41%);28 outline: transparent;29 overflow: hidden;30 cursor: pointer;31 user-select: none;32 white-space: nowrap;33 transition: 0.25s;34&#125;35.btn:hover &#123;36 background: hsl(var(--hue), 100%, 31%);37&#125;38.btn-primary &#123;39 --hue: 171;40&#125;41.btn-ghost &#123;42 color: hsl(var(--hue), 100%, 41%);43 background-color: transparent;44 border-color: hsl(var(--hue), 100%, 41%);45&#125;46.btn-ghost:hover &#123;47 color: white;48&#125;49.btn-border-stroke &#123;50 border-color: hsla(var(--hue), 100%, 41%, 0.35);51&#125;52.btn-border-stroke .btn-borders &#123;53 position: absolute;54 top: 0;55 left: 0;56 width: 100%;57 height: 100%;58&#125;59/* 用于动画的边框，用div构成 */60.btn-border-stroke .btn-borders .border-top &#123;61 position: absolute;62 top: 0;63 width: 100%;64 height: 1px;65 background: hsl(var(--hue), 100%, 41%);66 transform: scaleX(0);67 transform-origin: left;68&#125;69.btn-border-stroke .btn-borders .border-right &#123;70 position: absolute;71 right: 0;72 width: 1px;73 height: 100%;74 background: hsl(var(--hue), 100%, 41%);75 transform: scaleY(0);76 transform-origin: bottom;77&#125;78.btn-border-stroke .btn-borders .border-bottom &#123;79 position: absolute;80 bottom: 0;81 width: 100%;82 height: 1px;83 background: hsl(var(--hue), 100%, 41%);84 transform: scaleX(0);85 transform-origin: left;86&#125;87.btn-border-stroke .btn-borders .border-left &#123;88 position: absolute;89 left: 0;90 width: 1px;91 height: 100%;92 background: hsl(var(--hue), 100%, 41%);93 transform: scaleY(0);94 transform-origin: bottom;95&#125;96.btn-border-stroke:hover &#123;97 color: hsl(var(--hue), 100%, 41%);98 background: transparent;99&#125;100/* 边框显示为原来的大小倍数 */101.btn-border-stroke:hover .border-top,102.btn-border-stroke:hover .border-bottom &#123;103 transform: scaleX(1);104&#125;105.btn-border-stroke:hover .border-left,106.btn-border-stroke:hover .border-right &#123;107 transform: scaleY(1);108&#125;109/* 鼠标hover时，给边框添加过渡 */110.btn-border-stroke:hover .border-left &#123;111 transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0);112&#125;113.btn-border-stroke:hover .border-bottom &#123;114 transition: var(--ease-in-duration) cubic-bezier(1, 0, 0.8, 0);115&#125;116.btn-border-stroke:hover .border-right &#123;117 transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1);118&#125;119.btn-border-stroke:hover .border-top &#123;120 transition: var(--ease-out-duration) var(--ease-out-delay) cubic-bezier(0.2, 1, 0.2, 1);121&#125;122.btn-text-float-up::after &#123;123 position: absolute;124 content: attr(data-text);125 top: 0;126 left: 0;127 width: 100%;128 height: 100%;129 display: flex;130 justify-content: center;131 align-items: center;132 opacity: 0;133 /* 向下平移一段 */134 transform: translateY(35%);135 /* 绑定过渡效果 */136 transition: 0.25s ease-out;137&#125;138.btn-text-float-up .btn-text &#123;139 display: block;140 transition: 0.75s 0.1s cubic-bezier(0.2, 1, 0.2, 1);141&#125;142.btn-text-float-up:hover .btn-text &#123;143 opacity: 0;144 transform: translateY(-25%);145 transition: 0.25s ease-out;146&#125;147.btn-text-float-up:hover::after &#123;148 opacity: 1;149 transform: translateY(0);150 transition: 0.75s 0.1s cubic-bezier(0.2, 1, 0.2, 1);151&#125;152&lt;/style&gt; 利用绝对定位和padding在按钮里面添加多几个div，那么就可以实现多层边框。效果如下： Hover Button 按钮光影效果： hover me 四、代办事情列表 My Special Todo List to do list 1 to do list 2 to do list 3 to do list 4 五、内发光使用box-shadow的inset可以实现内发光效果,如下： 主要代码： 1&lt;div&gt;2 &lt;div class=\"loading\"&gt;&lt;/div&gt;3&lt;/div&gt;4&lt;style&gt;5 .loading &#123;6 position: relative;7 width: 8em;8 height: 8em;9 background: black;10 border-radius: 50%;11 box-shadow: inset 0.5em -0.5em crimson;12 animation: spin 2s linear infinite;13 &#125;14 .loading::before,15 .loading::after &#123;16 position: absolute;17 content: \"\";18 width: 100%;19 height: 100%;20 background: rgb(10, 10, 10);21 border-radius: inherit;22 box-shadow: inherit;23 &#125;24 .loading::before &#123;25 filter: blur(5px);26 &#125;27 .loading::after &#123;28 filter: blur(10px);29 &#125;30 @keyframes spin &#123;31 to &#123;32 transform: rotate(1turn);33 &#125;34 &#125; 35&lt;/style&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://cxhai.top/tags/css/"}]},{"title":"vue组件通信","slug":"vue组件","date":"2020-02-06T12:13:18.000Z","updated":"2020-02-08T15:20:38.323Z","comments":true,"path":"2020/02/06/vue组件/","link":"","permalink":"https://cxhai.top/2020/02/06/vue%E7%BB%84%E4%BB%B6/","excerpt":"说明记录学习vue组件间通信的知识。","text":"说明记录学习vue组件间通信的知识。 全局组件所有vue实例都可以使用。通过Vue.component()注册。 1&lt;div id=\"app\"&gt;2 &lt;test&gt;&lt;/test&gt;3&lt;/div&gt;4&lt;script&gt;5// 注册6Vue.component('test', &#123;7 data:function()&#123;8 return &#123;9 test:'test'10 &#125;11 &#125;,12 template: '&lt;h1&gt;&#123;&#123;test&#125;&#125;自定义组件!&lt;/h1&gt;'13&#125;)14// 创建根实例15new Vue(&#123;16 el: '#app'17&#125;)18&lt;/script&gt; 局部组件组件只能在当前实例中使用。在vue实例中注册。 1&lt;div id=\"app\"&gt;2 &lt;test&gt;&lt;/test&gt;3&lt;/div&gt;4&lt;script&gt;5 var Child = &#123;6 data:function()&#123;7 return&#123;8 count: '123'9 &#125;10 11 &#125;,12 template: '&lt;h1&gt;自定义组件!&#123;&#123;count&#125;&#125;&lt;/h1&gt;'13 &#125;14 new Vue(&#123;15 el: \"#app\",16 data: &#123;17 message: 'abcd'18 &#125;,19 components:&#123;20 'test': Child21 &#125;22 &#125;)23&lt;/script&gt; 在组件中的data属性，必须是一个函数，保证每个实例可以维护一份被返回对象的独立拷贝。 组件间的通信父组件向子组件传递数据父组件通过props向子组件传递数据。而props又分为静态props和动态props。***** prop是单向绑定的：当父组件发生变化时，将传递给子组件，但是不会反过来。 静态props静态props是在标签中，通过属性的方式传入值。 1&lt;div id=\"app\"&gt;2 &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;3 &lt;!-- 在父组件中插入子组件，通过 age = \"18\" 传入 --&gt;4 &lt;test age=\"18\"&gt;&lt;/test&gt;5&lt;/div&gt;6 &lt;script&gt;7 // 子组件8 var Child = &#123;9 data:function()&#123;10 return&#123;11 count: '123'12 &#125;13 &#125;,14 // 在子组件中，通过props接受父组件的age15 props: ['age'],16 template: '&lt;h1&gt;自定义组件!&#123;&#123;count&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/h1&gt;'17 &#125;18 // 创建vue实例19 new Vue(&#123;20 el: \"#app\",21 data: &#123;22 message: 'abcd'23 &#125;,24 // 注册局部组件25 components:&#123;26 // 注册组件，通过test标签使用子组件。27 'test': Child28 &#125;29 &#125;)30 &lt;/script&gt; 动态props类似v-bind绑定html特性到一个表达式，使用v-bind动态绑定props的值。 1&lt;div id=\"app\"&gt;2 &lt;div&gt;3 &lt;input v-model=\"parentMsg\"&gt;4 &lt;!-- 采用子组件显示父组件的信息 --&gt;5 &lt;!--插入子组件，通过message属性，把\"parentMsg = pMsg\"传递给子组件 --&gt;6 &lt;child :message=\"parentMsg\"&gt;&lt;/child&gt;7 &lt;/div&gt;8&lt;/div&gt;9&lt;script&gt;10// 注册全局组件11Vue.component('child', &#123;12 // 声明 props,接收父组件传来的message13 props: ['message'],14 // 同样也可以在 vm 实例中像 \"this.message\" 这样使用15 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'16&#125;)17// 创建根实例18new Vue(&#123;19 el: '#app',20 data: &#123;21 parentMsg: 'pMsg'22 &#125;23&#125;)24&lt;/script&gt; 子组件向父组件传递数据父组件使用props传递数据给子组件，但是如果子组件要把数据传递回去，就需要使用自定义事件。使用v-on绑定自定义事件，每个vue实例都实现了事件接口(Events interface) 使用$on(eventName) 监听事件使用$emit(eventName) 触发事件 而父组件中使用子组件的地方，可以使用v-on来监听子组件触发的事件。下面的例子，点击子组件的按钮，改变父组件的值。 1&lt;div id=\"counter-event-example\"&gt;2 &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt;3 &lt;!-- 父组件中，在插入子组件的地方直接使用v-on监听子组件触发的increment事件 --&gt;4 &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;5 &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;6&lt;/div&gt;7&lt;script&gt;8 // 子组件注册9Vue.component('button-counter', &#123;10 // 子组件按钮事件11 template: '&lt;button v-on:click=\"incrementHandler\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;',12 data: function () &#123;13 return &#123;14 counter: 015 &#125;16 &#125;,17 methods: &#123;18 // 点击子组件的按钮，通过$emit()向外触发一个名称为 increment 的事件19 incrementHandler: function () &#123;20 this.counter += 121 this.$emit('increment')22 &#125;23 &#125;,24&#125;)25new Vue(&#123;26 el: '#counter-event-example',27 data: &#123;28 total: 029 &#125;,30 methods: &#123;31 incrementTotal: function () &#123;32 this.total += 133 &#125;34 &#125;35&#125;)36&lt;/script&gt; 上面例子只是向外发了事件，那么怎么向外抛出一个值呢？这时可以使用$emit()的第二参数来提供这个值。 1&lt;button v-on:click=\"incrementHandler\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;23 methods: &#123;4 // 点击子组件的按钮，通过$emit()向外触发一个名称为 increment 的事件5 incrementHandler: function () &#123;6 this.counter += 17 this.$emit('increment',text)8 &#125;9 &#125; 在父组件中通过$event可以访问到由子组件抛出来的值。 1&lt;button-counter v-on:increment=\"total += $event\"&gt;&lt;/button-counter&gt; 如果increment关联的是一个方法，那么可以作为第一个参数传入。 1methods: &#123;2 incrementTotal: function (text) &#123;3 this.total += text4 &#125;5 &#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://cxhai.top/tags/vue/"}]},{"title":"vue样式绑定","slug":"vue样式绑定","date":"2020-02-06T07:01:02.000Z","updated":"2020-02-06T12:22:46.042Z","comments":true,"path":"2020/02/06/vue样式绑定/","link":"","permalink":"https://cxhai.top/2020/02/06/vue%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A/","excerpt":"vue样式绑定。","text":"vue样式绑定。 在vue中我们可以使用v-bind来设置样式属性。而v-bind在处理样式的时候可以采用三种语法。 一、对象语法适合较多的class名或者动态的class 1&lt;style&gt;2 .test&#123;3 width: 100px;4 height: 100px;5 background: green;6 &#125;7&lt;/style&gt;8&lt;div id=\"app\"&gt;9 &lt;div :class=\"&#123;'test':a&#125;\"&gt;&lt;/div&gt;10 &lt;div :class=\"obj\"&gt;11&lt;/div&gt;12&lt;script&gt;13 new Vue(&#123;14 el:'#app',15 data:&#123;16 a:true, /* 当a为true时，添加类名test */1718 // 直接传入对象写法19 obj: &#123;20 test:true // ture时添加test类名21 &#125;22 &#125;23 &#125;)24&lt;/script&gt; 二、数组语法适合较少的class名 1&lt;style&gt;2 .test-a&#123;3 width: 100px;4 height: 100px;5 background: green;6 &#125;7 .test-b:hover&#123;8 background: red;9 &#125;10&lt;/style&gt;11&lt;div id=\"app\"&gt;12 &lt;div :class=\"[a,b]\"&gt;&lt;/div&gt;13&lt;/div&gt;14&lt;script&gt;15 new Vue(&#123;16 el:'#app',17 data:&#123;18 a:\"test-a\",19 b:\"test-b\"20 &#125;21 &#125;)22&lt;/script&gt; 三、内联方式1&lt;div :style=\"&#123;width:w, height:h, background-color：bgc&#125;\"&gt;&lt;/div&gt;2&lt;!-- 或者直接传入对象 --&gt;3&lt;div :style=\"obj\"&gt;&lt;/div&gt;4data:&#123;5 w:\"200px\",6 h:\"200px\",7 c:\"red\",8 obj:&#123;9 width:\"200px\",10 height:\"200px\",11 background-color:\"red\",12 &#125;13&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://cxhai.top/tags/vue/"}]},{"title":"vue计算属性和侦听器","slug":"vue计算属性和侦听器","date":"2020-02-05T07:36:47.000Z","updated":"2020-02-06T12:22:28.590Z","comments":true,"path":"2020/02/05/vue计算属性和侦听器/","link":"","permalink":"https://cxhai.top/2020/02/05/vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/","excerpt":"vue计算属性。","text":"vue计算属性。 计算属性计算属性在处理复杂的逻辑上面很有用。具体的应用场景为：具有数据依赖关系的数据监听。在模板内的表达式虽然很方便，但是在模板内放太多的逻辑会让模板难以维护。例如下面的反转； 1&lt;div id=\"app\"&gt;2 &#123;&#123;message.split('').reverse().join('')&#125;&#125;3&lt;/div&gt; 采用计算属性： 1&lt;div id=\"app\"&gt;2 &lt;p&gt;原始字符串：&#123;&#123;message&#125;&#125;&lt;/p&gt;3 &lt;p&gt;反转的字符串：&#123;&#123;messageReverse&#125;&#125;&lt;/p&gt;4&lt;/div&gt;5&lt;script&gt;6 var vm = new Vue(&#123;7 el:'#app',8 data:&#123;9 message: 'welcome to vue'10 &#125;,11 /* 计算属性 */12 computed:&#123;13 messageReverse:function()&#123;14 return this.message.split('').reverse().join()15 &#125;16 &#125;17 &#125;)18&lt;/script&gt; 计算属性也可用methods代替，两者在效果上是一样的。computed是基于依赖缓存的，只有相关的依赖发生改变时，才会重新取值。methods，在重新渲染的时候，函数总会重新调用执行。因此，如果不希望缓存，采用methods代替即可。 计算属性setter计算属性默认只有getter, 如果需要，可以自己提供一个setter。 1&lt;script&gt;2 // 不设置setter（默认）3 data:&#123;4 a:1,5 b:26 &#125;7 computed: &#123;8 message:function()&#123;9 return this.a + this.b10 &#125;11 &#125;12 // 设置setter13 computed:&#123;14 message:&#123;15 // getter16 get: function()&#123;17 return this.a + this.b18 &#125;,19 // setters20 set: function(newValue)&#123;21 this.a = newValue22 &#125;23 &#125;24 &#125;25&lt;/script&gt; 侦听器计算属性在很多情况下都是适用的，但是有时需要一个自定义的侦听器。当需要在数据变化时，需要执行异步过程或开销比较大的操作时，watch方法会更有用。千米和米之间的换算： 1&lt;div id = \"computed_props\"&gt;2 千米 : &lt;input type = \"text\" v-model = \"kilometers\"&gt;3 米 : &lt;input type = \"text\" v-model = \"meters\"&gt;4&lt;/div&gt;5&lt;p id=\"info\"&gt;&lt;/p&gt;6&lt;script type = \"text/javascript\"&gt;7 var vm = new Vue(&#123;8 el: '#computed_props',9 data: &#123;10 kilometers : 0,11 meters:012 &#125;,13 methods: &#123;14 &#125;,15 computed :&#123;16 &#125;,17 watch : &#123;18 kilometers:function(val) &#123;19 this.kilometers = val;20 this.meters = this.kilometers * 100021 &#125;,22 meters : function (val) &#123;23 this.kilometers = val/ 1000;24 this.meters = val;25 &#125;26 &#125;27 &#125;);28 // $watch 是一个实例方法29 vm.$watch('kilometers', function (newValue, oldValue) &#123;30 // 这个回调将在 vm.kilometers 改变后调用31 document.getElementById (\"info\").innerHTML = \"修改前值为: \" + oldValue + \"，修改后值为: \" + newValue;32&#125;)33&lt;/script&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://cxhai.top/tags/vue/"}]},{"title":"策略模式","slug":"策略模式","date":"2020-01-28T03:08:59.000Z","updated":"2020-01-28T14:24:22.230Z","comments":true,"path":"2020/01/28/策略模式/","link":"","permalink":"https://cxhai.top/2020/01/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"说明在程序开发中，要实现某个功能有很多方案，要随意变换，那么就要用到策略模式。","text":"说明在程序开发中，要实现某个功能有很多方案，要随意变换，那么就要用到策略模式。 策略模式定义：定义一系列的算法，把他们封装起来，并且使它们可以相互替换。 使用策略模式计算奖金1var strategies = &#123;2 \"S\":function(salary)&#123;3 return salary * 44 &#125;,5 \"A\":function(salary)&#123;6 return salary * 37 &#125;,8 \"B\":function(salary)&#123;9 return salary * 210 &#125;11&#125;12var calculateBonus = function(level,salary)&#123;13 return strategies[level](salary)14&#125;15console.log(calculateBonus('S',20000)) // 80000 通过策略模式可以消除大量的条件分支语句（if/else）,在calculeteBonus()函数中只要获取策略对象的具体方法即可。 策略模式实现动画动画原理：在javascript中，可以通过连续改变元素的某个css属性，例如top,left等来实现动画。一些常见的缓动算法，接受四个参数。时间，起点，目标，持续时间。 1var tween = &#123;2 linear: function(time, begin, target, duration)&#123;3 return target * time / duration + begin4 &#125;,5 easeIn: function(time, begin, target, duration)&#123;6 return target * (time /= duration) * time + begin7 &#125;,8 strongEaseIn: function(time, begin, target, duration)&#123;9 return target * ( time /= duration ) * time * time * time * time + begin 10 &#125;,11 strongEaseout: function(time, begin, target, duration)&#123;12 return target * (( time = time / duration - 1) * time * time * time * time + 1) + begin; 13 &#125;,14 sineaseIn: function(time, begin, target, duration)&#123;15 return target * ( time /= duration) * time * time + begin; 16 &#125;,17 sineaseOUt: function(time, begin, target, duration)&#123;18 return target * ( ( time = time / duration - 1) * time * time + 1 ) + begin;19 &#125;20&#125; 定义Animate类，负责初始化dom节点。 1var Animate = function(dom)&#123;2 this.dom = dom3 this.startTime = 0 // 开始时间4 this.startPos = 0 // 起点位置5 this.endPos = 0 // 终点位置6 this.propertyName = null // 节点属性名7 this.easing = null // 缓动算法8 this.duration = null // 动画持续时间9&#125;10// 启动动画的方法11Animate.prototype.start = function(propertyName, endPos, duration, easing)&#123;12 this.startTime = +new Date13 // +new Date是new Date().getTime()的简写14 this.startPos = this.dom.getBoundingClientRect()[ propertyName ]; // dom 节点初始位置15 //Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。16 this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名17 this.endPos = endPos; // dom 节点目标位置18 this.duration = duration; // 动画持续事件19 this.easing = tween[ easing ]; // 缓动算法2021 var self = this;22 var timer = setInterval(function()&#123; // 启动定时器，开始执行动画23 if ( self.step() === false )&#123; // 如果动画已结束，则清除定时器24 clearInterval( timer ); 25 &#125;26 &#125;, 19 );27&#125;;28// 控制每一帧 29Animate.prototype.step = function()&#123;30 var t = +new Date; // 取得当前时间31 if ( t &gt;= this.startTime + this.duration )&#123; // (1)32 this.update( this.endPos ); // 更新小球的 CSS 属性值33 return false; // 条件满足则退出函数34 &#125;35 var pos = this.easing( t - this.startTime, this.startPos,36 this.endPos - this.startPos, this.duration );37 // pos 为小球当前位置38 this.update( pos ); // 更新小球的 CSS 属性值39&#125;; 40//更新属性41Animate.prototype.update = function( pos )&#123;42 this.dom.style[ this.propertyName ] = pos + 'px';43&#125;;44// 测试45// html代码 &lt;div id='div' style=\"...\"&gt;我是div&lt;div&gt;46var div = document.getElementById('div')47var animate = new Animate(div)48animate.start('left',500,800,'strongEaseOut') 策略模式-表单验证1&lt;html&gt;2 &lt;body&gt;3 &lt;form action=\"http:// xxx.com/register\" id=\"registerForm\" method=\"post\"&gt;4 请输入用户名：&lt;input type=\"text\" name=\"userName\"/ &gt;5 请输入密码：&lt;input type=\"text\" name=\"password\"/ &gt;6 请输入手机号码：&lt;input type=\"text\" name=\"phoneNumber\"/ &gt;7 &lt;button&gt;提交&lt;/button&gt;8 &lt;/form&gt;9 &lt;script&gt;10 var registerForm = document.getElementById( 'registerForm' );11 registerForm.onsubmit = function()&#123;12 if ( registerForm.userName.value === '' )&#123;13 alert ( '用户名不能为空' );14 return false;15 &#125;16 if ( registerForm.password.value.length &lt; 6 )&#123;17 alert ( '密码长度不能少于 6 位' );18 return false;19 &#125;20 if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( registerForm.phoneNumber.value ) )&#123;21 alert ( '手机号码格式不正确' );22 return false;23 &#125;24 &#125;25 &lt;/script&gt;26 &lt;/body&gt;27&lt;/html&gt; 上面的脚本中包含了大量的条件语句，包含了所有的校验规则。下面采用策略模式来重构表单验证代码。先将所有的校验逻辑封装起来 1var strategies = &#123;2 isNonEmpty: function( value, errorMsg )&#123; // 不为空3 if ( value === '' )&#123;4 return errorMsg ;5 &#125;6 &#125;,7 minLength: function( value, length, errorMsg )&#123; // 限制最小长度8 if ( value.length &lt; length )&#123;9 return errorMsg;10 &#125;11 &#125;,12 isMobile: function( value, errorMsg )&#123; // 手机号码格式13 if ( !/(^1[3|5|8][0-9]&#123;9&#125;$)/.test( value ) )&#123;14 return errorMsg;15 &#125;16 &#125;17&#125;; 应该有个类，可以向input节点添加需要的验证规则。 1var Validator = function()&#123;2 this.cache = []; // 保存校验规则3&#125;;4// 添加校验规则的函数5Validator.prototype.add = function( dom, rule, errorMsg )&#123;6 var ary = rule.split( ':' ); // 把 strategy 和参数分开7 this.cache.push(function()&#123; // 把校验的步骤用空函数包装起来，并且放入 cache8 var strategy = ary.shift(); // 用户挑选的 strategy9 ary.unshift( dom.value ); // 把 input 的 value 添加进参数列表10 ary.push( errorMsg ); // 把 errorMsg 添加进参数列表11 return strategies[ strategy ].apply( dom, ary );12 &#125;);13&#125;;14// 开启验证的函数，并且返回验证结果15Validator.prototype.start = function()&#123;16 for ( var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ]; )&#123;17 var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息18 if ( msg )&#123; // 如果有确切的返回值，说明校验没有通过19 return msg;20 &#125;21 &#125;22&#125;; 2324// 向表单添加认证25var validataFunc = function()&#123;26 var validator = new Validator(); // 创建一个 validator 对象27 /***************添加一些校验规则****************/28 validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空' );29 validator.add( registerForm.password, 'minLength:6', '密码长度不能少于6位' );30 validator.add( registerForm.phoneNumber, 'isMobile', '手机号码格式不正确' );31 var errorMsg = validator.start(); // 获得校验结果32 return errorMsg; // 返回校验结果33&#125;34// 获取节点并实现onsubmit事件 35var registerForm = document.getElementById( 'registerForm' );36registerForm.onsubmit = function()&#123;37 var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验38 if ( errorMsg )&#123;39 alert ( errorMsg );40 return false; // 阻止表单提交41 &#125;42&#125;;","categories":[],"tags":[{"name":"javascript 设计模式","slug":"javascript-设计模式","permalink":"https://cxhai.top/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"javascript单例模式","slug":"javascript单例模式","date":"2020-01-26T08:37:31.000Z","updated":"2020-01-28T03:09:36.490Z","comments":true,"path":"2020/01/26/javascript单例模式/","link":"","permalink":"https://cxhai.top/2020/01/26/javascript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"说明单例模式是一种常用的模式。","text":"说明单例模式是一种常用的模式。 单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。在javascript中，我们经常使用全局的对象作为单例。例如：var a = {}这个对象a的确是独一无二的。但是全局变量存在很多问题，它很容易造成命名空间的污染，也很容易被覆盖。 简单实现单例模式实现一个标准的单例很简单，使用一个变量来标志当前是否已经为某个类创建过对象即可。 1var Singleton = function(name)&#123;2 this.name = name3 // 标志4 this.instance = null5&#125;6Singleton.prototype.getName = function()&#123;7 console.log(this.name)8&#125;9Singleton.getInstance = function(name)&#123;10 if( !this.instance )&#123;11 this.instance = new Singleton(name)12 &#125;13 return this.instance14&#125;15var a = new Singleton.getInstance('a')16var b = new Singleton.getInstance('b')17console.log(a === b) // true 或者把标志和判断都放在一个闭包中实现 1var Singleton = function(name)&#123;2 this.name = name3&#125;4Singleton.prototype.getName = function()&#123;5 console.log(this.name)6&#125;7Singleton.getInstance = (function()&#123;8 var instance = null9 return function(name)&#123;10 if(!this.instance)11 this.instance = new Singleton(name)12 retrun instance13 &#125;14&#125;)() 虽然实现了单例模式，但是上面的代码只是简单说明实现的一个办法，而且缺点也很明显，这里要使用Singleton.getInstance()来获取对象，和使用new XXX()不同。 透明的单例模式对上面的代码进行改进。创建唯一的div节点： 1var createDiv = (function()&#123;2 var instance;3 var Create = function(html)&#123;4 if(instance)&#123;5 return instance6 &#125;7 this.html = html8 this.init()9 return instance = this10 &#125;11 createDiv.prototype.init = function()&#123;12 var div = document.createElement('div')13 div.innerHTML = this.html14 document.bosy.appendChlid(div)15 &#125;16 return Create()17&#125;)();18var a = new CreateDiv('a')19var b = new CreateDiv('b')20console.log(a === b) // true CreateDiv的构造函数，第一创建了对象和执行初始化init方法，第二保证对象只有一个。这个构造函数看起来怪该的，而且如果要将这个类变成普通的类就必须得改造构造函数。 用代理模式实现单例模式先实现简单的类 1var createDiv = function(html)&#123;2 this.html = html3 this.init()4 createDiv.prototype.init = function()&#123;5 var div = document.createElement('div')6 div.innerHTML = this.html7 document.body.appehdChlid(div)8 &#125;9&#125; 引入代理类 1var Proxy= (function()&#123;2 var instance;3 var Create = function()&#123;4 if( !instance)&#123;5 instence = new CreateDiv(html)6 &#125;7 return instance8 &#125;9&#125;)()10var a = new Proxy('a')11var b = new Rpoxy('b')12console.log(a === b) // true 通过这样的组合，我们实现了单例模式。createDiv的类实现数据的初始化和其他方法的实现。Proxy代理类则让创建的类唯一。 惰性单例惰性单例指的是在需要的时候才创建对象实例。上面的例子都是基于‘类’的单例，但是在实际的javascript开发中并不适用。下面以登录浮窗为例，结合全局变量实现惰性单例。 1&lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt;2var createLoginLayer = (function()&#123;3 var div; // 标志4 return function()&#123;5 if ( !div )&#123;6 div = document.createElement( 'div' );7 div.innerHTML = '我是登录浮窗';8 div.style.display = 'none';9 document.body.appendChild( div );10 &#125;11 return div;12 &#125;13&#125;)(); 1415 document.getElementById( 'loginBtn' ).onclick = function()&#123;16 var loginLayer = createLoginLayer();17 loginLayer.style.display = 'block';18 &#125;;19 &lt;/script&gt;20&lt;/html&gt; 通用的惰性单例管理单例的逻辑其实是可以抽出来的。这个逻辑就是：用一个变量来标志是否创建过对象。var obj;if( !obj ){ obj = new XXX;}逻辑抽离实现 1var getSingle = function(fn)&#123;2 var result;3 return function()&#123;4 return result || (result = fn.apply(this,arguments))5 &#125;6&#125; 创建函数 1var Create = function(html,ele)&#123;2 var div = document.createElement(ele)3 div.innerHTML = html4 div.style.display = 'none'5 document.body.appendChlid(div)6 return div7&#125;8// 把创建函数和需要创建的元素传入9var CreateSingle = getSingle(Create，'iframe')10document.getElementById('btn').onclick = function()&#123;11 var iframe = CreateSingle()12 iframe.src = 'XXX'13&#125;","categories":[],"tags":[{"name":"javascript 设计模式","slug":"javascript-设计模式","permalink":"https://cxhai.top/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"函数节流和分时函数","slug":"函数节流和分时函数","date":"2020-01-25T09:19:46.000Z","updated":"2020-01-25T13:53:55.569Z","comments":true,"path":"2020/01/25/函数节流和分时函数/","link":"","permalink":"https://cxhai.top/2020/01/25/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%88%86%E6%97%B6%E5%87%BD%E6%95%B0/","excerpt":"函数节流","text":"函数节流 (1)、函数频繁调用的场景 window.onresize事件。当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常的高。 mousemove事件。 上传进度。(2)、函数节流的原理借助setTimeout()，对函数进行延迟执行。(3)、函数节流的代码实现、实现有许多种，这里主要写一种。1var throttle= function(fn, interval)&#123;2 var _fn = fn, // 保存需要被延迟执行的函数引用3 timer, // 定时器4 firstTime = true; // 是否第一次调用5 return function()&#123;6 var args = arguments,7 _this = this;8 9 if(firstTime)&#123; // 如果是第一次调用，不需要延迟执行10 _fn.apply(_this,args)11 return firstTime = false12 &#125;13 if(timer)&#123; // 如果定时器还在,说明前一次延迟执行还没有完成14 return false15 &#125;16 timer = setTimeout(function()&#123;// 延迟一段时间执行17 clearTimeout(timer);18 timer = null;19 _fn.apply(_this,args)20 &#125;,interval || 500)21 &#125;22&#125;2324window.onresize = throttle(function()&#123;25 console.log(1)26&#125;, 1000) 分时函数一些大量的添加DOM节点的操作显然会让浏览器吃不消。例如：1var arr = []2for (var i =0; i&lt;=1000; i++)&#123;3 arr.push(i)4&#125;5var addDom = function(data)&#123;6 for(var i =0, l=data.lenth; i&lt;l; i++)&#123;7 var div = document.createElement('div')8 div.innerHTML = i9 document.body.appendChild(div)10 &#125;11&#125;12addDom(arr) 浏览器一下子创建1000个节点，我们可以让创建节点分批的进行，比如200毫秒创建10个节点。1/**2 * @description: 3 * @param &#123;Array&#125; arr // 创建节点用到的数据4 * @param &#123;Function&#125; fn // 创建节点函数封装 5 * @param &#123;Number&#125; count // 一次创建的数量 6 * @return: Function7 */8var timeChunk = function(arr,fn,count)&#123;9 var obj,10 timer;11 var len = arr.length;12 var start = function()&#123;13 for(var i=0; i&lt;Math.min(count || 1, len); i++)&#123;14 var obj = arr.shidt();15 fn(obj);16 &#125;17 &#125;18 return function()&#123;19 timer = setInterval(function()&#123;20 if(arr.lenth === 0)&#123;21 return clearInterval(timer)22 &#125;23 start()24 &#125;,200)25 &#125;26&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"高阶函数理解","slug":"高阶函数理解","date":"2020-01-23T05:50:14.000Z","updated":"2020-01-24T09:03:36.009Z","comments":true,"path":"2020/01/23/高阶函数理解/","link":"","permalink":"https://cxhai.top/2020/01/23/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/","excerpt":"说明说说高阶函数。","text":"说明说说高阶函数。 高阶函数高阶函数指的是满足下列条件之一的函数 函数可以作为参数传递 函数可以作为返回值输出一、作为参数传递作为参数传递是，回调函数用的比较多。在ajax异步请求中，回调函数用的很频繁。1var getIUserInfo = function(userId,callback)&#123;2 $.ajax('http://xxx.com/getUserInfo?' + userId, function(data)&#123;3 if(typeof callback === \"Function\") &#123;4 callback(data)5 &#125; 6 &#125;)7&#125; 又比如数组的排序函数，sort()默认排序是把字符转为unicode码值进行比较，很多时候需要自定义排序规则。1[1,2,4,6,3,].sort(function(a,b)&#123;2 return a-b // 从小到大3 // return b-a 从大到小4&#125;) 作为返回值输出这里拿判断数据来举个栗子：1var isString = function(obj)&#123;2 return Object.prototype.toString.call(obj) === '[Object String]'3&#125;;4var isArray = function(obj)&#123;5 return Object.prototype.toString.call(obj) === '[Object Array]'6&#125;7var isNumber = function(obj)&#123;8 return Object.prototype.toString.call(obj) === '[Object Number]'9&#125;10// 可以看出大部分代码都是相同的11// 我们进行一个封装12var isType = funciton(type)&#123;13 // 函数作为返回值14 return function(obj)&#123;15 return Object.prototype.toString.call(obj) === '[Object'+ type + ']' 16 &#125;17&#125; 高阶函数实现AOPAOP(面向切面编程)的主要作用是把一些跟核心业务无关的功能抽离出来。通过Function.prototype实现。 1Function.prototype.before = function(beforefn)&#123;2 var _self = this3 return function()&#123;4 beforefn.apply(this,arguments) // 执行beforefn()5 return _self.apply(this,arguments); // 执行原函数6 &#125;7&#125;8Function.prototype.after = function(afterfn)&#123;9 var _self = this;10 return function()&#123;11 var result = _self.apply(this, arguments)12 afterfn.apply(this,arguments)13 return result14 &#125;15&#125;16var func = function()&#123;17 console.log('2')18&#125;19func = func.before(function()&#123;20 console.log('1')21&#125;).after(function()&#123;22 console.log('3')23&#125;)24func() // 1 2 3 这样就动通过AOP的方式，动态的向func()函数植入打印1和打印3的函数。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"关于闭包","slug":"关于闭包","date":"2020-01-19T15:06:34.000Z","updated":"2020-01-23T05:47:35.532Z","comments":true,"path":"2020/01/19/关于闭包/","link":"","permalink":"https://cxhai.top/2020/01/19/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/","excerpt":"说明闭包是一个难懂又必须搞懂的概念。这里结合变量作用域来说明闭包的概念。","text":"说明闭包是一个难懂又必须搞懂的概念。这里结合变量作用域来说明闭包的概念。 作用域的理解，主要针对es5，不涉及ES6。 变量作用域变量作用域指变量的有效范围。对于javascript的作用域，这里做一个概述。 一、“javascript无块级作用域”（es5）,（es6引入let关键字，用于指定变量的作用域）二、js采用函数作用域在js中函数即作用域，在外部无法访问函数内部作用域的变量。 1function func()&#123;2 var inner = 'inner'3&#125;4func();5console.log(inner) // 报错 三、JavaScript的作用域链由于js采用函数作用域，那么出现嵌套函数时，就会出现作用域链。 1var ex = 'outerWin'2function Func()&#123;3 var ex = 'inner'4 function innerFunc()&#123;5 var ex = 'innerFun'6 console.log(ex)7 &#125;8 innerFunc()9&#125;10Func() 上面代码出现了三个作用域，全局作用域》Func()》innerFunc(),寻找ex变量时，会沿着作用域链，从内（当前变量所在作用域）往外找，如果都没有这个变量，则抛出异常。 四、javascript的作用域链执行前已创建javascript的作用域在被执行之前已经创建，之后再执行会按照作用域去寻找。 1var ex = 'outerWin'2function Func()&#123;3 var ex = 'inner'4 function innerFunc()&#123;5 console.log(ex)6 &#125;7 return innerFunc8&#125;9var result = Func()10result() // inner 在result()调用之前，作用域链已经存在。全局作用域-&gt;Func()作用域-&gt;innerFunc()作用域执行result()时，result指代的是innerFunc()函数，innerFunc()的作用域并没有ex这个变量，那么找到Func()作用域，找到，那么输出ex。再看看下面的这个例子: 1var ex = 'outerWin'2function Bar()&#123;3 console.log(ex)4&#125;5function Foo()&#123;6 var foo = 'foo'7 return Bar8&#125;9var result = Foo()10result() //outerWin 这段代码在执行前，创建了两条作用域链:全局作用域-&gt;Bar()作用域全局作用域-&gt;Foo()作用域执行result()时，result指代Bar()函数，那么在Bar()函数里面寻找变量。 五、声明提前javascript的函数在被执行之前，会将其中的变量全部声明，而不赋值。 1function Func()&#123;2 console.log(x)3 var x = 14&#125;5Func() // undefined6// 上面写法相当于7function Func()&#123;8 var x;9 console.log(x)10 x = 111&#125;12Func() 闭包按理，一个函数执行完，退出，那么函数内部的局部变量会被销毁。我们对上面的第四点时的代码做修改， 1var func = function()&#123;2 var a = 1;3 return function()&#123;4 a++;5 console.log(a)6 &#125;7&#125;8var f = func()9f() // 210f() // 3 结合上面的作用域链，我们可以理解第一次执行f()，输出2，函数执行结束，变量a应该销毁了才对，但是后面继续执行为什么会输出3？因为当执行 var f = func() 时，f返会一个匿名函数的引用，它可以访问到func()被调用时产生的环境（也叫上下文，有新的函数执行都会产生一个新的上下文，这个上下文决定了我们可以访问到哪些变量，函数等），既然调用f()就可以访问函数的上下文，那么自然可以访问到a变量。可见闭包是将函数内部和函数外部连接的桥梁，简单理解就是，闭包是能够读取其他函数内部变量的函数。 闭包的弊端简单概括的话，会造成内存泄漏。但单单是从占用内存这方面来说，变量放在闭包和全局作用域下，对内存的影响是一致的，不能说成内存泄漏。闭包和内存泄漏的地方是：使用闭包的同时比较容易形成循环引用，如果闭包的作用域中保存着一些DOM节点，这时候就有可能造成内存泄漏。解决办法：将循环引用的变量设置为null即可。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"call()和apply的用途","slug":"artitle4","date":"2020-01-18T15:16:54.000Z","updated":"2020-01-19T15:07:03.990Z","comments":true,"path":"2020/01/18/artitle4/","link":"","permalink":"https://cxhai.top/2020/01/18/artitle4/","excerpt":"说明说说call()和apply()在实际开发中的用途。","text":"说明说说call()和apply()在实际开发中的用途。 一、改变this的指向call()和apply()最常用的是改变函数内部的this指向。 1var obj1 = &#123;2 name: 'obj1'3&#125;4var obj2 = &#123;5 name: 'obj2'6&#125;7window.name = 'win'8var getName = function()&#123;9 console.log(this.name)10&#125;11getName() // win12getName.call(obj1) // obj113getName.apply(obj2) // obj214// call()和apply()的主要区别在于传入多个参数时的传参形式。 在实际开发中，经常会遇到this指向被不经意改变场景。例如： 1doucument.getElementById('div1').onclick = function()&#123;2 alert(this.id) // div13 var func = function()&#123;4 alert(this.id) 5 &#125;6 func() // undefined7 func.call(this); // div18&#125; 二、Function.prototype.bind大部分高级浏览器都实现了内置的Function.prototype.bind,用来指定函数内部的this指向。语法: fun.bind(this,arg1,arg2…)bind()方法会创建一个新的函数，称为绑定函数，fun方法在this环境下调用。模拟实现bind(): 1Function.prototype.bind = function(context)&#123;2 var self = this; // 这时候this指向func3 // bind() 返回的是一个函数4 return function()&#123; // 返回一个新的函数5 return self.apply(context,arguments) 6 &#125;7&#125;8var obj = &#123;9 name: 'obj'10&#125;11var func = function()&#123;12 console.log(this.name)13&#125;.bind(obj) // 相当于func.bind()14// 因此, var self = this, 中的this指向func()15// 那么执行func.bind() 将获得bind()的返回函数16func() // obj17// func() 即是执行返回函数 self.apply(context，arguments),即是func.apply(...),相当于执行自身 上面是简单版的bind()实现，通常我们会像下面这样实现: 1Function.prototype.bind = function()&#123;2 var self = this,3 // shift()删除数组的第一个元素，并返回被删除元素4 context = [].shift.call(arguments)5 // 通过slice()将剩余参数转为数组6 args = [].slice.call(arguments)7 return function()&#123;8 return self.apply(context, [].concat.call(args, [].slice.call(arguments)))9 // 两次调用可能都会传入参数，需要做参数整合10 &#125;11&#125;1213var obj = &#123;14 name: 'obj'15&#125;16var func = function(a,b,c,d)&#123;17 console.log(this.name)18 console.log([a,b,c,d])19&#125;.bind(obj,1,2) // 第一次bind()传入2021func(3,4) // [1,2,3,4] // 第二次func()传入 三、借用其他对象的方法借用的第一种场景是”借用构造函数”，可以实现类似继承的效果: 1var A = function(name)&#123;2 this.name = name3&#125;4var B = function ()&#123;5 A.apply(this, arguments)6&#125;7B.prototype.getName = function()&#123;8 return this.name9&#125;10var b = new B('b')11console.log(b.getName()) // b 借用场景二arguments的灵活使用:函数的arguments是一个类数组对象。类数组对象: 和数组一样有下标，但是没有数组的方法，不能进行排序操作或者添加元素等。 1(function()&#123;2 Array.prototype.push.call(arguments, 3);3 console.log(arguments); // 输出[1,2,3]4&#125;)(1,2)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"javascript的this指向","slug":"artitle3","date":"2020-01-17T12:16:18.000Z","updated":"2020-01-18T14:34:07.260Z","comments":true,"path":"2020/01/17/artitle3/","link":"","permalink":"https://cxhai.top/2020/01/17/artitle3/","excerpt":"说明记录一些关于this指向的知识。","text":"说明记录一些关于this指向的知识。 this的指向 作为对象的方法调用， this指向该调用对象 1var obj = &#123;2 a:1,3 func:function()&#123;4 console.log(this === obj) // true5 console.log(this.a) // 16 &#125;7&#125;8obj.func()910// 注意：11var x = obj.func // 把函数体拉到外面，12x() // 相当于作为普通函数，在window下直接调用，this指向window 作为普通函数调用（直接调用，不作为对象的属性被调用,this指向全局对象。浏览器中this为window,node中为global) 1var a = 1;2var aa = function()&#123;3 console.log(this);4 console.log(this.a);5&#125;6aa() // 输出window和1 *注意，在strict模式下，直接调用this已经视为undefined。 构造函数调用（new操作）， this指向返回的这个对象 1var A = function()&#123;2 this.a = 13 console.log(this.a)4&#125;5var obj = new A() // 1 *注意，如果构造函数显式的返回对象，返回对象（返回其他类型会被忽略），那么构造函数中使用this初始化的变量没有意义。 1// 显式返回对象2var A = function()&#123;3 this.a = 14 return &#123;5 a: 36 &#125;7&#125;8var a = new A()9console.log(a.a) // 3 这里简单说一下new的过程 1.创建一个空的Object对象，var obj = new Object() 2.将构造函数中的this指向刚创建的obj对象 3.将创建的obj的proto指向构造函数的prototype。 4.执行构造函数中的代码 call(),apply(),bind()调用 call()和apply()的作用基本相同的，都是更改对象的内部指针，即改变对象的this指向。它们主要的区别是传入参数形式不同。当函数需要传递多个变量时，call()接受一系列的单独变量，apply()接受一个数组(array)作为参数。call(obj,arg1,arg2…) apply(obj,[arg1,arg2…]) *注意：当第一个参数存入undefined、null时，默认指向window 1var obj1 = &#123;2 name:'obj1',3 getName:function()&#123;4 return this.name5 &#125;6&#125;7var obj2 = &#123;8 name: 'obj2'9&#125;10console.log(obj1.getName()) // obj111console.log(obj1.getName.call(obj2)) // obj2 bind()的使用和call()差不多，区别是bind()返回的是函数以及bind()接受的参数列表的使用bind()方法不会立即执行，而是返回一个改变上下文this后的函数。而原函数中的this并没有改变。1var obj = &#123;2 name: 'obj'3&#125;4function printName()&#123;5 console.log(this.name)6&#125;7var func = printName.bind(obj)8console.log(func) // function()&#123;...&#125;9func() // obj ES6箭头函数this指向默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）;即使是call，apply，bind等方法也不能改变箭头函数this的指向。箭头函数实例：1var obj = &#123;2 num: 10,3 func: function()&#123;4 console.log(this) ; // obj5 setTimeout(() =&gt; &#123;6 console.log(this) // obj7 &#125;)8 &#125;,9 func1: () =&gt; &#123;console.log(this)&#125; // window10&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"prototype和__proto__","slug":"artitle2","date":"2020-01-15T12:33:40.000Z","updated":"2020-02-08T07:07:44.470Z","comments":true,"path":"2020/01/15/artitle2/","link":"","permalink":"https://cxhai.top/2020/01/15/artitle2/","excerpt":"说明搞懂javascript的prototype和proto。","text":"说明搞懂javascript的prototype和proto。 在javascript中，根对象为Object.prototype。在js遇到的所有对象，实际上都是从Object.prototype克隆而来的，Object.prototype对象就是所有对象的原型。看看下面的代码: 1let obj1 = new Object();2let obj2 = &#123;&#125;3console.log(Object.getPrototype(obj1) === Object.prototype) // true4console.log(Object.getPrototype(obj2) === Object.prototype) // true因此在创建对象or函数的时候，会有一些自定义的属性， 定义函数的时候，预定义属性就是prototype,而这个prototype是一个普通的对象。 定义普通对象or实例化对象的时候，预定义的属性是proto(不会有prototype这个属性),这个proto指向的是这个object的constructor的prototype。 定义函数时控制台试试下面的代码: 1// 定义函数时2let objFactory = function()&#123;&#125;3console.log(objFactory.prototype) 4//这个prototype对象包含constructor（指向函数本身）和__proto__(对象都有这个属性),刚才说的proto指向对象的构造函数的prtotype。那么objFactory.prototype这个对象的构造函数是什么呢？ 所有的对象都是基于Object.prototype,所以objFactory.prototype这个对象的构造函数就是Object.prototype控制台试试下面的代码: 1console.log(objFactory.prototype.__proto__)2console.log(Object.prototype)3// 它们打印出来的是同一个东西。 因此，也可以说Object.prototype是所有函数的爸爸，声明一个函数的时候也就相当于对Object的实例化。 定义或者实例对象时实例化对象 1let obj = new objFactory()2console.log(obj) 可以看到没有obj中没有prototype这个属性console.log(obj.prototype) // undefined而proto指向对象的构造函数的prototype 1console.log(b.__proto__=== B.prototype) // true 这就是prototype和proto的区别。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://cxhai.top/tags/javascript/"}]},{"title":"hexo+githubPage搭建个人博客","slug":"artitle1","date":"2019-12-13T16:00:00.000Z","updated":"2019-12-14T13:04:35.462Z","comments":true,"path":"2019/12/14/artitle1/","link":"","permalink":"https://cxhai.top/2019/12/14/artitle1/","excerpt":"说明 搭建个人博客已经好几天了,还没有写过文章，这里主要转载别人的几篇文章，教程很详细，想要搭建个人博客网站的可以看看！","text":"说明 搭建个人博客已经好几天了,还没有写过文章，这里主要转载别人的几篇文章，教程很详细，想要搭建个人博客网站的可以看看！ 入门使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 页面美化Hexo 博客优化之博客美化系列 实用功能添加Hexo 博客优化之实用功能添加系列 自定义页面hexo的模板，新建一个页面默认都是嵌入到模板中的，如果想要自己写一个页面也是ok的。Hexo 博客自定义一个不使用主题模板渲染的独立页面 搭建图床如果用于展示图片的话，建议搭建图床，这样在页面通过连接加载图片资源就可以了。Github+jsDelivr+PicGo 打造稳定快速、高效免费图床 总结本人也是一路跟着教程，一步步的走下来，也遇过不少坑。 坑一右下角的动画人物，我第一次尝试着弄一个，成功之后就修改不了了，只能控制显示和隐藏，修改配置文件，甚至把动画人物插件删除都不管用，至今未解决。 坑二域名添加了github地址后，不要急着使用域名访问网页，等个10分钟这样。我当时瞎搞了一两个小时，怎么都访问不了，睡醒就可以通过域名访问了。频繁的修改域名解释，可能会弄坏域名。 坑三不蒜子以前的资源网站已过期，一些模板可能没有更新js资源地址，手动替代模板中的资源路径即可 坑四gitment评论系统，不同的浏览器要登录一遍才可以评论，查了下说可以使用nigx代理解决。如果在搭建的过程中遇到了问题，可以私信我，一起探讨。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cxhai.top/tags/hexo/"},{"name":"gitPage","slug":"gitPage","permalink":"https://cxhai.top/tags/gitPage/"}]}]}